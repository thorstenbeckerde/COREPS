<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CORE: Perceptual Storyteller</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&family=Source+Sans+Pro:wght@400;600;700&family=Patrick+Hand&family=VT323&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* ---
        Creative Redesign Theme Engine
        --- */

        :root {
            /* Fallback variables (Constellation Theme) */
            --color-bg-deep-space: #1a1a2e;
            --color-bg-space: #162447;
            --color-bg-nebula: #1f4068;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #a0a0c0;
            --color-accent-gold: #ffc700;
            --color-accent-magenta: #e43f5a;
            --color-border: #3b3b58;
            --bg-anim-duration: 200s;
            --bg-anim-play-state: running;
            --font-main: 'Source Sans Pro', sans-serif;
            --font-serif: 'Lora', serif;
        }

        /* --- Dark Theme: "Constellation" --- */
        body[data-theme="dark"] {
            --color-bg-deep-space: #1a1a2e;
            --color-bg-space: #162447;
            --color-bg-nebula: #1f4068;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #a0a0c0;
            --color-accent-gold: #ffc700;
            --color-accent-magenta: #e43f5a;
            --color-border: #3b3b58;
            --font-main: 'Source Sans Pro', sans-serif;
            --font-serif: 'Lora', serif;
        }

        /* --- Light Theme: "Parchment" --- */
        body[data-theme="light"] {
            --color-bg-deep-space: #fdf6e3; /* Parchment bg */
            --color-bg-space: #f4eade;    /* Slightly darker parchment */
            --color-bg-nebula: #e9dac9;    /* UI elements */
            --color-text-primary: #584c39; /* Sepia text */
            --color-text-secondary: #85755f;
            --color-accent-gold: #c06c27;  /* Burnt orange accent */
            --color-accent-magenta: #a52a2a; /* Brown-red accent */
            --color-border: #dcd0b9;
            --font-main: 'Source Sans Pro', sans-serif;
            --font-serif: 'Lora', serif;
        }

        /* --- Sketch Theme (Revised Font) --- */
        body[data-theme="sketch"] {
            --color-bg-deep-space: #f5f5f5;
            --color-bg-space: #ffffff;
            --color-bg-nebula: #e9e9e9;
            --color-text-primary: #3d3d3d;
            --color-text-secondary: #6b6b6b;
            --color-accent-gold: #ff9800;
            --color-accent-magenta: #f44336;
            --color-border: #9e9e9e;
            --font-main: 'Patrick Hand', cursive; /* NEW: More legible handwritten font */
            --font-serif: 'Patrick Hand', cursive; /* NEW: More legible handwritten font */
        }
        
        /* --- NEW: Visual Novel Theme --- */
        body[data-theme="visual-novel"] {
            --color-bg-deep-space: #eef2f7; /* Light blue-grey sky */
            --color-bg-space: #ffffff;    /* Clean white dialogue box */
            --color-bg-nebula: #d1d9e6;    /* UI elements */
            --color-text-primary: #2c3e50; /* Dark slate text */
            --color-text-secondary: #56789a;
            --color-accent-gold: #ff6b81;  /* Cherry blossom pink accent */
            --color-accent-magenta: #4a90e2; /* Bright blue for choices */
            --color-border: #b8c6d9;
            --font-main: 'Noto Sans JP', sans-serif;
            --font-serif: 'Lora', serif;
        }

        /* --- NEW: Final Fantasy Theme --- */
        body[data-theme="final-fantasy"] {
            --color-bg-deep-space: #000c2f;
            --color-bg-space: #0a1f5a;
            --color-bg-nebula: linear-gradient(180deg, #1e3a8a 0%, #0c1b4b 100%);
            --color-text-primary: #f0f8ff;
            --color-text-secondary: #a7c0ff;
            --color-accent-gold: #fde047; /* Gold Saucer Gold */
            --color-accent-magenta: #60a5fa; /* Materia Blue */
            --color-border: #4a78b5;
            --font-main: 'Lora', serif;
            --font-serif: 'Lora', serif;
        }
        
        /* --- NEW: Point & Click Theme --- */
        body[data-theme="point-and-click"] {
            --color-bg-deep-space: #222034;
            --color-bg-space: #45283c;
            --color-bg-nebula: #30283f;
            --color-text-primary: #f7f7f7;
            --color-text-secondary: #a3a3a3;
            --color-accent-gold: #ffcc00; /* Yellow for interaction */
            --color-accent-magenta: #e04f5f; /* Red for important items */
            --color-border: #62364a;
            --font-main: 'VT323', monospace;
            --font-serif: 'VT323', monospace;
        }

        @keyframes stars {
            0% { background-position: 0 0; }
            100% { background-position: -10000px 5000px; }
        }

        body {
            font-family: var(--font-main);
            background-color: var(--color-bg-deep-space);
            color: var(--color-text-primary);
            overscroll-behavior: none;
            overflow: hidden;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        h1, h2, h3, h4, .font-serif {
            font-family: var(--font-serif);
        }

        #appContainer {
            width: 100vw;
            height: calc(var(--vh, 1vh) * 100);
            display: flex;
            flex-direction: column;
            background-color: var(--color-bg-deep-space);
        }

        .toolbar {
            flex-shrink: 0;
            position: relative;
            background-color: rgba(22, 36, 71, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--color-border);
            z-index: 20; /* Ensure toolbar is above canvas */
        }
        
        body[data-theme="light"] .toolbar { background-color: rgba(244, 234, 222, 0.8); }
        body[data-theme="sketch"] .toolbar { background-color: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.1); backdrop-filter: none;}
        body[data-theme="visual-novel"] .toolbar { background-color: rgba(255, 255, 255, 0.7); border-bottom-color: var(--color-border); }
        body[data-theme="final-fantasy"] .toolbar { background: var(--color-bg-nebula); border-image: linear-gradient(to right, #4a78b5, #fde047, #4a78b5) 1; }
        body[data-theme="point-and-click"] .toolbar { background-color: var(--color-bg-nebula); backdrop-filter: none; border-bottom: 2px solid #000; }

        #mainContent {
            position: relative;
            flex-grow: 1;
            overflow: hidden;
            z-index: 10; /* Ensure canvas is below toolbar */
        }

        #noteCanvasContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--color-bg-deep-space);
            cursor: grab;
            touch-action: none;
        }
        #noteCanvasContainer:focus { outline: none; }
        #noteCanvasContainer.panning { cursor: grabbing; }

        #transformContainer {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        #noteCanvas {
            width: 16000px;
            height: 12000px;
            position: relative;
            background-color: transparent;
        }

        body[data-theme="dark"] #noteCanvas {
            background-image: 
                url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"),
                url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAAXNSR0IArs4c6QAAAyhJREFUWEetmD1WHDEUh59LCAgEAlKwsCCBCAgoiBBICBbiG0CCQAGJgAQSgYgPEEiAWhAQCAQCBVop3e7dndnZ2f+2J+k4zkz27Ew2PZl5p55n7plnnpUaGAwGOWc7ZzcfiWkMCHlCnvhcHl8uX24+k11p1qf5/f5S52RiQmIeAYsA/P48eQ4037y2/7azv5bX6/WfB/B+fn4iIyJkCqBvb2+7vY6ffxHkvCRZANjd3X0F0P39/aYgC+RkZtIMgG3b/n1XbZoYkIoDRb5v03g2gI4scl5cXV1t7dE/sSExf+IDd8x6qGQDqCAGeI8QkgwAR8dHX/E2uVwub2xsvC3A4wcGBkpN0hBw+u3trX25ubm9RQSbDbMhQBxPj8g/AChB3wHgrQAaANiWkbAJwB2A+42NjT9K8gI8PDz8E/p16239CqBzzjkH4DQA7wFoALALgBuAfQC63G/sT4uLi+8SYJpmy/0jfgGgA/h5D1sJMK2pAGhdo4/tAGCb5vEEUEsVAGyB+3L+1L16t7u7+74gC4A8kZMpBVgJqH3bpo+sD4D9gB+A+wH8j9eDMRqfATgBOA3A0g02BwA/a8DmAxAALNsi4A1A7wG84uPjc9O0AA8PDw+lR0eIAMA3gLQA3ALgFoAvAD4A3AOg73b+lY3t7T/xJ+1+q5eHMIgA+g3Azm3bjz6nANgA2AbgQvowgJ0BvP+p/8mG1qN/YkJifj4+PjY2tq+urvY2d3R0PAGkP98i4DcA/QfQz/b2dhPAV1cACABYAHS5X3q0/PsG4F/A/gGoBliN8+NxiAFQA42wfmwAwCYAewC+AwgA5gC4R0AnADQAbAPwz4/Xo1EEv/8E+G8dPRugI9v28yUAKAFsQ0AAVANkO51O+7s3mIymT4jI70sA9ADsCqD7+/tN2oV7B8BFqeuo8P//AbgDcASAAPADgEoAOgAUASAAbwHo27ZNF23K8y+ZJAIBAgL1nAAAAAElFTkSuQmCC");
            background-repeat: repeat, repeat;
            animation-name: stars;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            animation-duration: var(--bg-anim-duration);
            animation-play-state: var(--bg-anim-play-state);
        }
        
		body[data-theme="light"] #noteCanvas {
			background-color: var(--color-bg-deep-space);
		}
        body[data-theme="sketch"] #noteCanvas {
            background-color: #f5f5f5;
        }

        #svgCanvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; z-index: 0;
        }
        
        body[data-theme="dark"] #svgCanvas {
             filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.3));
        }

        .chorus-chunk {
            position: absolute;
            background-color: var(--color-bg-space);
            backdrop-filter: blur(8px);
            border: 1px solid var(--color-border);
            border-radius: 12px 6px 12px 6px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.05);
            min-width: 250px;
            min-height: 150px;
            display: flex; flex-direction: column;
            overflow: visible;
            transition: border-color 0.3s, box-shadow 0.3s, opacity 0.3s, transform 0.3s;
            z-index: 1;
        }
        
        body[data-theme="light"] .chorus-chunk {
             box-shadow: 0 4px 10px rgba(88, 76, 57, 0.2);
             backdrop-filter: none;
        }
        
        body[data-theme="sketch"] .chorus-chunk {
             box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
             border-radius: 4px 3px 5px 2px;
             border-width: 2px;
        }

        body[data-theme="visual-novel"] .chorus-chunk {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(44, 62, 80, 0.15);
            backdrop-filter: none;
        }

        body[data-theme="final-fantasy"] .chorus-chunk {
            background: var(--color-bg-nebula);
            border-radius: 6px;
            border: 2px solid;
            border-image: linear-gradient(to bottom, #a7c0ff, #1e3a8a) 1;
            box-shadow: 0 0 15px rgba(96, 165, 250, 0.3), inset 0 0 8px rgba(0,0,0,0.5);
        }

        body[data-theme="point-and-click"] .chorus-chunk {
            border: 2px solid #000;
            border-radius: 0;
            box-shadow: 4px 4px 0px #000;
            backdrop-filter: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        body[data-theme="point-and-click"] .chorus-chunk:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #000;
        }

        .chorus-chunk.selected-chunk,
        .chorus-chunk.linking-source-chunk {
            border-color: var(--color-accent-gold);
            box-shadow: 0 0 20px -2px var(--color-accent-gold), 0 6px 20px rgba(0,0,0,0.5);
        }
        
        body[data-theme="light"] .chorus-chunk.selected-chunk,
        body[data-theme="light"] .chorus-chunk.linking-source-chunk {
             box-shadow: 0 0 15px -2px var(--color-accent-gold), 0 4px 10px rgba(88, 76, 57, 0.3);
        }

        body[data-theme="sketch"] .chorus-chunk.selected-chunk {
            border-width: 3px;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
        }
         body[data-theme="sketch"] .chorus-chunk.linking-source-chunk {
            outline: 2px dashed #16a34a;
            border-color: #16a34a;
        }

        body[data-theme="point-and-click"] .chorus-chunk.selected-chunk,
        body[data-theme="point-and-click"] .chorus-chunk.linking-source-chunk {
             box-shadow: 4px 4px 0px var(--color-accent-gold);
             border-color: #000;
        }

        .chunk-header {
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: move;
            border-bottom: 1px solid var(--color-border);
            user-select: none;
            overflow: hidden;
            display: flex;
            justify-content: space-between;
            align-items: center;
            touch-action: none;
            transition: color 0.3s, background-color 0.3s;
        }
        
        body[data-theme="sketch"] .chunk-header {
            padding: 10px 10px;
            font-size: 1.4em; /* Increased for revised sketch theme */
            letter-spacing: 0.5px;
        }

        body[data-theme="visual-novel"] .chunk-header {
             background-color: #f8f9fa; /* Slightly off-white header */
        }

        body[data-theme="final-fantasy"] .chunk-header {
             background: none;
             text-shadow: 0 0 5px #000;
        }
        
        body[data-theme="point-and-click"] .chunk-header {
             font-size: 1.2rem;
             padding: 4px 8px;
             background-color: #30283f;
             border-bottom: 2px solid #000;
        }

        .chunk-header-title { display: flex; flex-direction: column; align-items: flex-start; gap: 0.1rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chunk-header-main { display: flex; align-items: center; gap: 0.5rem; }
        .chunk-header-main .shape-icon svg { width: 14px; height: 14px; stroke-width: 2; fill: none; transition: stroke 0.3s; }
        .chunk-color-symbol { font-size: 1.1em; }
        .chunk-functional-essence { font-size: 0.7rem; font-weight: 400; font-style: italic; transition: color 0.3s;}
        
        .chunk-actions { display: flex; align-items: center; }
        .chunk-action-btn { background: none; border: none; cursor: pointer; padding: 4px; margin-left: 4px; line-height: 1; border-radius: 50%; transition: background-color 0.2s; }
        .chunk-action-btn svg { width: 18px; height: 18px; stroke: var(--color-text-secondary); stroke-width: 2; }
        .chunk-action-btn:hover { background-color: rgba(0,0,0,0.1); }
        .chunk-action-btn:hover svg { stroke: var(--color-text-primary); }
        .delete-chunk-btn:hover svg { stroke: var(--color-accent-magenta); }
        .ai-chunk-btn:hover svg { stroke: var(--color-accent-gold); }
        .link-chunk-btn.linking-active svg { stroke: var(--color-accent-gold) !important; animation: pulse 1.5s infinite; }
        
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }

        .chunk-content { flex-grow: 1; padding: 12px; font-size: 0.9rem; overflow-y: auto; outline: none; color: var(--color-text-primary); }
        body[data-theme="sketch"] .chunk-content { font-size: 1.3em; line-height: 1.5; } /* Increased for revised sketch theme */
        body[data-theme="point-and-click"] .chunk-content { font-size: 1.2rem; line-height: 1.4; }
        
        .chunk-content p { margin-bottom: 0.5em; }
        .resize-handle { width: 16px; height: 16px; background-color: rgba(255,255,255,0.1); position: absolute; right: -2px; bottom: -2px; cursor: se-resize; border-top-left-radius: 8px; z-index: 10; touch-action: none; border: 1px solid var(--color-border); }
        body[data-theme="sketch"] .resize-handle { background-color: #bbb; right: -4px; bottom: -4px; border-top-left-radius: 4px; }
        body[data-theme="point-and-click"] .resize-handle { border-radius: 0; background-color: #000; border: 2px solid var(--color-border); }
        
        .connecting-line { stroke-width: 2.5; fill: none; }
        body[data-theme="dark"] .connecting-line { filter: blur(0.5px); }
        body[data-theme="sketch"] .connecting-line { filter: url(#sketchy); stroke-width: 2; }
        body[data-theme="point-and-click"] .connecting-line { stroke-width: 3px; }

        .link-type-triggers { /* solid */ }
        .link-type-reveals { stroke-dasharray: 8, 4; }
        .link-type-echoes { stroke-dasharray: 2, 6; }
        .link-type-contrasts { stroke-dasharray: 12, 4, 4, 4; }
        .arrow-head { }
        .link-label { font-family: 'Lora', serif; font-size: 14px; fill: var(--color-text-primary); text-anchor: middle; dominant-baseline: middle; pointer-events: none; paint-order: stroke; stroke: var(--color-bg-deep-space); stroke-width: 4px; stroke-linecap: butt; stroke-linejoin: miter; }
        body[data-theme="sketch"] .link-label { stroke: none; background-color: rgba(255,255,255,0.7); font-size: 16px; }

        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); backdrop-filter: blur(5px); display: flex; justify-content: center; align-items: center; z-index: 10000; }
        .modal-content { background-color: var(--color-bg-space); padding: 24px; border-radius: 8px; box-shadow: 0 10px 35px rgba(0,0,0,0.5); width: 90%; max-width: 500px; border: 1px solid var(--color-border); color: var(--color-text-primary); }
        .modal-content h2 { font-family: 'Lora', serif; margin-bottom: 1rem; }
        
        body[data-theme="final-fantasy"] .modal-content {
             background: var(--color-bg-nebula);
             border: 2px solid;
             border-image: linear-gradient(to bottom, #a7c0ff, #1e3a8a) 1;
        }

        body[data-theme="point-and-click"] .modal-content {
            border-radius: 0;
            border: 2px solid #000;
            box-shadow: 4px 4px 0px #000;
        }
        
        .form-input, .form-textarea, .form-select { width: 100%; padding: 10px 12px; border: 1px solid var(--color-border); border-radius: 6px; margin-bottom: 12px; background-color: var(--color-bg-deep-space); color: var(--color-text-primary); }
        .form-input[type="checkbox"] { width: auto; }
        .form-textarea { min-height: 100px; resize: vertical; }
        body[data-theme="point-and-click"] .form-input, body[data-theme="point-and-click"] .form-textarea, body[data-theme="point-and-click"] .form-select { border-radius: 0; border: 2px solid #000; }
        
        .btn { padding: 8px 16px; border-radius: 6px; font-weight: 600; font-family: 'Source Sans Pro', sans-serif; cursor: pointer; transition: all 0.2s ease; margin-right: 8px; border: 1px solid transparent; display: inline-flex; align-items: center; justify-content: center; white-space: nowrap; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        body[data-theme="point-and-click"] .btn { border-radius: 0; border: 2px solid #000; box-shadow: 2px 2px 0px #000; }
        body[data-theme="point-and-click"] .btn:active:not(:disabled) { transform: translate(2px, 2px); box-shadow: 0 0 0 #000; }
        
        .btn-primary { background-color: var(--color-accent-gold); color: var(--color-bg-deep-space); border-color: var(--color-accent-gold); }
        .btn-primary:hover:not(:disabled) { transform: translateY(-1px); }
        body[data-theme="dark"] .btn-primary:hover:not(:disabled) { background-color: #ffdb4d; box-shadow: 0 4px 8px rgba(255, 199, 0, 0.2); }
        body[data-theme="light"] .btn-primary:hover:not(:disabled) { background-color: #d47e3a; box-shadow: 0 4px 8px rgba(192, 108, 39, 0.3); }
        body[data-theme="sketch"] .btn-primary { color: #fff; }
        body[data-theme="sketch"] .btn-primary:hover:not(:disabled) { background-color: #fb8c00; box-shadow: none; }
        body[data-theme="point-and-click"] .btn-primary:hover:not(:disabled) { transform: none; }


        .btn-secondary { background-color: var(--color-nebula); color: var(--color-text-primary); border-color: var(--color-border); }
        .btn-secondary:hover:not(:disabled) { transform: translateY(-1px); }
        body[data-theme="dark"] .btn-secondary:hover:not(:disabled) { background-color: #2a528a; border-color: #4a78b5; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        body[data-theme="light"] .btn-secondary:hover:not(:disabled) { background-color: #dcd0b9; border-color: #c9bda9; box-shadow: 0 4px 8px rgba(88, 76, 57, 0.2); }
        body[data-theme="sketch"] .btn-secondary:hover:not(:disabled) { background-color: #d1d5db; box-shadow: none; }
        body[data-theme="point-and-click"] .btn-secondary:hover:not(:disabled) { transform: none; }


        .btn-danger { background-color: var(--color-accent-magenta); color: white; border-color: var(--color-accent-magenta); }
        .btn-danger:hover:not(:disabled) { transform: translateY(-1px); }
        body[data-theme="dark"] .btn-danger:hover:not(:disabled) { background-color: #fa5a75; box-shadow: 0 4px 8px rgba(228, 63, 90, 0.3); }
        body[data-theme="light"] .btn-danger:hover:not(:disabled) { background-color: #b93a3a; box-shadow: 0 4px 8px rgba(165, 42, 42, 0.3); }
        body[data-theme="sketch"] .btn-danger:hover:not(:disabled) { background-color: #c62828; box-shadow: none; }
        body[data-theme="point-and-click"] .btn-danger:hover:not(:disabled) { transform: none; }
        
        /* New Donate button style to use the primary accent color */
        .btn-donate { background-color: var(--color-accent-magenta); color: white; border-color: var(--color-accent-magenta); }
        .btn-donate:hover:not(:disabled) { transform: translateY(-1px); }
        body[data-theme="dark"] .btn-donate:hover:not(:disabled) { background-color: #fa5a75; box-shadow: 0 4px 8px rgba(228, 63, 90, 0.3); }
        body[data-theme="light"] .btn-donate:hover:not(:disabled) { background-color: #b93a3a; box-shadow: 0 4px 8px rgba(165, 42, 42, 0.3); }
        body[data-theme="sketch"] .btn-donate:hover:not(:disabled) { background-color: #c62828; box-shadow: none; }
        body[data-theme="visual-novel"] .btn-donate { background-color: var(--color-accent-gold); border-color: var(--color-accent-gold); } /* Use gold for VN theme */
        body[data-theme="final-fantasy"] .btn-donate { background-color: var(--color-accent-gold); border-color: var(--color-accent-gold); } /* Use gold for FF theme */
        body[data-theme="point-and-click"] .btn-donate:hover:not(:disabled) { transform: none; }

        #helpModal .modal-content, #messageModal .modal-content, #unlinkModal .modal-content, #linkEditModal .modal-content, #templatesModal .modal-content, #settingsModal .modal-content, #aiActionModal .modal-content, #donateModal .modal-content, #sessionRestoreModal .modal-content { display: flex; flex-direction: column; max-height: 80vh; }
        #messageText, #help-scroll-content, #unlinkList, #templateList, #settings-scroll-content, #chunkListContainer { max-height: 60vh; overflow-y: auto; padding-right: 1rem;}
        body.linking-mode { cursor: crosshair; }
        body.linking-mode .chorus-chunk:not(.linking-source-chunk):hover { border-color: var(--color-accent-magenta); }
        body[data-theme="sketch"] body.linking-mode .chorus-chunk:not(.linking-source-chunk):hover { outline: 2px dashed var(--color-accent-gold); border-color: var(--color-border); }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; line-height: 1; transition: color 0.2s; }
        .close-button:hover, .close-button:focus { color: var(--color-accent-gold); text-decoration: none; cursor: pointer; }
        .help-section { border-bottom: 1px solid var(--color-border); padding-bottom: 12px; margin-bottom: 12px; }
        .help-section:last-child { border-bottom: none; }
        .help-section h3 { font-family: 'Lora', serif; font-size: 1.1rem; font-weight: 600; margin-bottom: 8px; color: var(--color-accent-gold); }
        .help-section ul { list-style-type: disc; margin-left: 20px; }
        .help-section li { margin-bottom: 6px; }
        .help-section code { background-color: var(--color-bg-deep-space); padding: 2px 6px; border-radius: 4px; font-size: 0.85em; border: 1px solid var(--color-border); }

        /* Dropdowns */
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { display: none; position: absolute; background-color: var(--color-bg-space); min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.5); z-index: 100; right: 0; border-radius: 6px; padding: 4px; border: 1px solid var(--color-border); }
        .dropdown-content button { color: var(--color-text-primary); display: block; width: 100%; text-align: left; padding: 8px 12px; background: none; border: none; cursor: pointer; }
        .dropdown-content button:hover { background-color: var(--color-nebula); }
        .dropdown-content.show { display: block; }
        
        .unlink-item:hover {
            background-color: var(--color-nebula);
        }

        /* Grid and Center Marker Styles */
        #canvasGrid, #gridCenterMarker, #canvasCenterStar {
            display: none; /* Hidden by default */
            pointer-events: none;
        }
        body.grid-visible #canvasGrid {
            display: block;
        }
        body.center-star-visible #canvasCenterStar {
            display: block;
        }
        #gridPattern path {
            stroke: var(--color-border);
            stroke-width: 1.5;
            fill: none;
            opacity: 0.6;
            vector-effect: non-scaling-stroke;
        }
        body[data-theme="sketch"] #canvasGrid rect {
            filter: url(#sketchy-grid);
        }
        #gridCenterMarker path {
            stroke: var(--color-accent-magenta);
            stroke-width: 2;
            stroke-dasharray: 4, 4;
            opacity: 0.8;
            fill: none;
        }
        
        /* New Center Star Styles */
        #canvasCenterStar path {
            fill: var(--color-accent-gold);
            stroke: white;
            stroke-width: 1.5;
            filter: drop-shadow(0 0 8px var(--color-accent-gold));
            transition: fill 0.3s, filter 0.3s;
        }


        /* NEW: Chunk List Styles */
        #chunkListPanel {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 350px;
            background-color: var(--color-bg-space);
            border: 1px solid var(--color-border);
            border-top: none;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 19; /* Below toolbar but above canvas */
            padding: 8px;
        }
        body[data-theme="point-and-click"] #chunkListPanel { border-radius: 0; }
        #chunkListContainer { padding-right: 0; }
        .chunk-list-item {
            padding: 8px 10px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 4px;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chunk-list-item:hover {
            background-color: var(--color-bg-nebula);
        }
        .chunk-list-item.selected {
             background-color: var(--color-accent-gold);
             color: var(--color-bg-deep-space);
        }
        body[data-theme="point-and-click"] .chunk-list-item.selected { color: #000; }
        .chunk-list-item-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Footer */
        footer { background-color: var(--color-bg-deep-space); border-top: 1px solid var(--color-border); }
    </style>
</head>
<body data-theme="light">
    <div id="appContainer">
        <div class="toolbar p-3 flex flex-col sm:flex-row items-center justify-center sm:justify-between gap-3 print:hidden">
            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="addChunkBtn" class="btn btn-primary" title="Add Chunk (A)">Add New Idea</button>
                <button id="templatesBtn" class="btn btn-secondary" title="Load a narrative template">Templates</button>
                <button id="clearCanvasBtn" class="btn btn-danger" title="Clear Canvas">Clear</button>
            </div>

            <div class="flex items-center justify-center gap-1 relative"> 
				 <button id="undoDeleteBtn" class="btn btn-secondary" title="Undo Last Delete (Ctrl/Cmd+Z)" disabled>Undo</button>
				 <button id="zoomOutBtn" class="btn btn-secondary !p-2" title="Zoom Out (-)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M20 12H4" /></svg>
                 </button>
                 <button id="zoomResetBtn" class="btn btn-secondary" title="Reset Zoom (100%)">100%</button>
                 <button id="chunkListToggleBtn" class="btn btn-secondary" title="Toggle Idea List (L)">List</button>
                 <button id="zoomInBtn" class="btn btn-secondary !p-2" title="Zoom In (+)">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6" /></svg>
                 </button>

                 <div id="chunkListPanel" class="hidden">
                     <div id="chunkListContainer">
                        </div>
                 </div>
            </div>

            <div class="flex items-center flex-wrap justify-center gap-2">
                <span id="chunkCountDisplay" class="text-sm text-gray-400 mx-2">Ideas: 0</span>
                 <div class="dropdown">
                    <button id="exportBtn" class="btn btn-secondary">Export</button>
                    <div id="exportDropdownContent" class="dropdown-content">
                        <button data-format="txt">Simple TXT</button>
                        <button data-format="narrative-txt">Narrative TXT</button>
                        <button data-format="json">JSON</button>
                        <hr class="my-1 border-gray-600">
                        <button data-format="yarn">Yarn Spinner (.yarn)</button>
                        <button data-format="twee">Twee (.twee)</button>
                        <button data-format="ink">Ink (.ink)</button>
                        <button data-format="renpy">Ren'Py (.rpy)</button>
                        <button data-format="i7">Inform 7 (.ni)</button>
                         <hr class="my-1 border-gray-600">
                        <button data-format="articy">articy:draft</button>
                    </div>
                </div>
                <button id="saveBtn" class="btn btn-secondary" title="Save to File (Ctrl/Cmd+S)">Save</button>
                <button id="loadBtn" class="btn btn-secondary" title="Load from File (Ctrl/Cmd+O)">Load</button>
                <button id="settingsBtn" class="btn btn-secondary !p-2" title="Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" /></svg>
                </button>
                <button id="helpBtn" class="btn btn-secondary !p-2" title="Help (?)">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" /></svg>
                </button>
                <button id="donateBtn" class="btn btn-donate !p-2" title="Support CORE">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>

        <div id="mainContent">
            <div id="noteCanvasContainer" tabindex="-1">
                <div id="transformContainer">
                    <div id="noteCanvas">
                        <svg id="svgCanvas"></svg>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center p-2 text-xs text-gray-500 print:hidden">
        &copy; <span class="copyrightYear"></span> <a href="https://www.thorstenbecker.de" target="_blank" rel="noopener noreferrer" class="hover:underline text-gray-400">Thorsten Becker</a>. CORE: Perceptual Storyteller.
    </footer>

    <div id="addChunkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2 class="font-serif text-xl mb-4">Add New Idea</h2>
            <label for="chunkTypeSelect" class="block mb-1 font-medium">Idea Type:</label>
            <select id="chunkTypeSelect" class="form-select"></select>
            <label for="addChunkShapeSelect" class="block mb-1 mt-3 font-medium">Functional Shape:</label>
            <select id="addChunkShapeSelect" class="form-select"></select>
            <label for="addChunkColorSelect" class="block mb-1 mt-3 font-medium">Emotional Color:</label>
            <select id="addChunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end">
                <button id="cancelAddChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmAddChunkBtn" class="btn btn-primary">Add</button>
            </div>
        </div>
    </div>
    <div id="editChunkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2 class="font-serif text-xl mb-4">Edit Idea</h2>
            <input type="hidden" id="editingChunkId">
            <label for="editChunkTypeSelect" class="block mb-1 font-medium">Idea Type:</label>
            <select id="editChunkTypeSelect" class="form-select"></select>
            <label for="editChunkShapeSelect" class="block mb-1 mt-3 font-medium">Functional Shape:</label>
            <select id="editChunkShapeSelect" class="form-select"></select>
            <label for="editChunkColorSelect" class="block mb-1 mt-3 font-medium">Emotional Color:</label>
            <select id="editChunkColorSelect" class="form-select"></select>
			<div class="mt-4 border-t border-gray-700 pt-4">
				<h3 class="font-semibold mb-2">Ren'Py Assets (Optional)</h3>
				<p class="text-xs text-gray-500 mb-2">Enter the filenames for assets you will use in your Ren'Py project (e.g., "classroom.png", "yuki_happy.png", "school_theme.mp3").</p>
				
				<label for="renpyBgInput" class="block mb-1 mt-3 font-medium">Background Image:</label>
				<input type="text" id="renpyBgInput" class="form-input" placeholder="e.g., bg_forest.jpg">

				<label for="renpySpriteInput" class="block mb-1 mt-3 font-medium">Character Sprite:</label>
				<input type="text" id="renpySpriteInput" class="form-input" placeholder="e.g., yuki_happy.png">

				<label for="renpyMusicInput" class="block mb-1 mt-3 font-medium">Music Track:</label>
				<input type="text" id="renpyMusicInput" class="form-input" placeholder="e.g., main_theme.mp3">
			</div>
            <div id="editModalActions" class="mt-6 flex justify-end">
                <button id="cancelEditChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmEditChunkBtn" class="btn btn-primary">Save Changes</button>
            </div>
        </div>
    </div>
    <div id="linkEditModal" class="modal hidden">
        <div class="modal-content">
            <h2 id="linkEditTitle" class="font-serif text-xl mb-4">Create Relationship</h2>
            <input type="hidden" id="linkSourceId">
            <input type="hidden" id="linkTargetId">
            <label for="linkTypeSelect" class="block mb-1 font-medium">Relationship Type:</label>
            <select id="linkTypeSelect" class="form-select"></select>
            <label for="linkLabelInput" class="block mb-1 mt-3 font-medium">Relationship Note (optional):</label>
            <input type="text" id="linkLabelInput" class="form-input" placeholder="(e.g., The smell reminds her of home)">
            <div class="mt-6 flex justify-end">
                <button id="cancelLinkEditBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmLinkEditBtn" class="btn btn-primary">Create Link</button>
            </div>
        </div>
    </div>
    
    <div id="templatesModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2 class="font-serif text-xl mb-4">Load a Narrative Template</h2>
            <p class="text-sm text-gray-400 mb-4">Choose a built-in template or load your own constellation.</p>
            <div id="templateList" class="space-y-2 mb-4 border-b border-gray-700 pb-4 pr-4 overflow-y-auto overflow-x-hidden box-border"></div>
             <div class="flex flex-col space-y-2">
                <button id="saveCanvasAsTemplateBtn" class="btn btn-secondary w-full">Save Canvas as Template</button>
                <button id="loadCustomTemplateBtn" class="btn btn-secondary w-full">Load Custom Template...</button>
             </div>
        </div>
    </div>
    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeSettingsModalBtn" class="close-button">&times;</span>
            <h2 class="font-serif text-xl mb-4">Settings</h2>
            <div id="settings-scroll-content">
                <div>
                    <h3 class="font-semibold text-lg mb-2">API Key</h3>
                    <p class="text-xs text-gray-500 mb-2">Required for AI features. Your key is saved only in this browser's local storage.</p>
                    <input type="password" id="geminiApiKeyInput" class="form-input" placeholder="Enter your Google AI API key here">
                    <p class="text-xs text-gray-500 mb-4">Get a key from <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-400 hover:underline">Google AI Studio</a>.</p>
                </div>
                 <div class="mt-4 border-t border-gray-700 pt-4">
                    <h3 class="font-semibold text-lg mb-2">Theme</h3>
                     <label for="themeSelect" class="block mb-1 font-medium">Select a visual theme</label>
                    <select id="themeSelect" class="form-select"></select>
                </div>
                <div class="mt-4 border-t border-gray-700 pt-4">
                    <h3 class="font-semibold text-lg mb-2">Canvas Helpers</h3>
                    <div class="flex items-center justify-between mb-2">
                        <label for="gridToggle" class="cursor-pointer">Show Canvas Grid</label>
                        <input type="checkbox" id="gridToggle" class="form-input">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="centerStarToggle" class="cursor-pointer">Show Glowing Center Star</label>
                        <input type="checkbox" id="centerStarToggle" class="form-input">
                    </div>
                </div>
                <div class="mt-4 border-t border-gray-700 pt-4">
                    <h3 class="font-semibold text-lg mb-2">Canvas Background</h3>
                    <div class="flex items-center justify-between mb-2">
                        <label for="bgAnimationToggle" class="cursor-pointer">Animated Background</label>
                        <input type="checkbox" id="bgAnimationToggle" class="form-input">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="bgAnimationSpeed" class="cursor-pointer">Animation Speed</label>
                        <input type="range" id="bgAnimationSpeed" min="10" max="400" value="200" class="form-input w-1/2">
                    </div>
                </div>
            </div>
             <div class="mt-6 flex justify-end pt-4 border-t border-gray-700">
                <button id="saveSettingsBtn" class="btn btn-primary">Save & Close</button>
            </div>
        </div>
    </div>
     <div id="aiActionModal" class="modal hidden">
        <div class="modal-content">
             <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2 class="flex items-center font-serif text-xl mb-4"><span class="mr-2 text-yellow-400">✨</span>AI Assistant</h2>
            <p class="text-sm text-gray-400 mb-4">Use AI to expand and explore your narrative ideas. Current chunk content will be used as context.</p>
            <div class="space-y-2">
                <button id="aiActionDeepenBtn" class="btn btn-secondary w-full justify-start">✨ Deepen Sensory Details</button>
                <button id="aiActionInternalStateBtn" class="btn btn-secondary w-full justify-start">✨ Explore Internal State</button>
                <button id="aiActionSuggestEchoBtn" class="btn btn-secondary w-full justify-start">✨ Suggest an "Echo"</button>
            </div>
        </div>
    </div>
    <div id="unlinkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2 class="font-serif text-xl mb-4">Manage Relationships</h2>
            <p class="text-sm text-gray-400 mb-4">Remove or edit outgoing relationships from this chunk.</p>
            <div id="unlinkList" class="space-y-2"></div>
            <div class="mt-6 flex justify-end">
                <button id="closeUnlinkModalBtn" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>
    <div id="helpModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeHelpModalSpan" class="close-button">&times;</span>
            <h2 class="font-serif text-xl mb-4">CORE Quick Help</h2>
            <div id="help-scroll-content">
                 <div class="help-section">
                    <h3>What is CORE Perceptual Storyteller?</h3>
                    <p class="mb-2">This is a tool for mapping stories from an emotional and perceptual perspective. Instead of focusing on plot points, it helps you structure a narrative based on environmental cues, internal feelings, and shifts in a character's perception.</p>
                    <p>The goal is to visually choreograph the "inner" story—the one of feeling and experience—that drives the external plot. To learn more about the design philosophy, you can <a href="https://drive.google.com/file/d/11jn05gmpEyiPX0lOwA9Rak5YJbsMXDS2/view?usp=sharing" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">read the full manifesto here</a>.</p>
                </div>
                <div class="help-section">
                    <h3>✨ The Core Method</h3>
                    <p>CORE is built on three layers of visual grammar:</p>
                    <ul>
                        <li><strong>Chunks (The "What"):</strong> Self-contained moments of perception, feeling, or thought.</li>
                        <li><strong>Shapes (The "How"):</strong> Defines a chunk's function (Internal, External, Shift, etc.).</li>
                        <li><strong>Colors (The "Feeling"):</strong> Represents the emotional tone (Conflict, Calm, etc.).</li>
                        <li><strong>Relationships (The "Why"):</strong> Lines show how chunks influence each other, such as cause-and-effect, thematic echoes, or branching choices in a narrative.</li>
                         <li><strong>AI Assistant (The "Spark"):</strong> Use the ✨ icon in any chunk to deepen details, explore internal states, or suggest thematic echoes. Requires a Google AI API key.</li>
                    </ul>
                </div>
                <div class="help-section">
                    <h3>Game Design & Ren'Py Export</h3>
                    <p class="mb-2">CORE PS can function as a powerful pre-production and scripting tool for the free <a href="https://www.renpy.org/" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">Ren'Py visual novel engine</a>. By adding asset filenames to your chunks, you can export a functional <code>.rpy</code> script file.</p>
                    <h4>How it Works:</h4>
                    <ol class="list-decimal ml-5">
                        <li class="mb-2"><strong>Add Asset Info:</strong> In the "Edit Idea" modal for any chunk, you will find optional fields for "Ren'Py Assets". You can specify a background image, a character sprite, and a music track. Use the exact filenames (e.g., <code>bg_library.png</code>, <code>yuki_sad.png</code>, <code>mystery.mp3</code>).</li>
                        <li class="mb-2"><strong>Export to Ren'Py:</strong> Use the <code>Export > Ren'Py (.rpy)</code> option to download your story as a script file.</li>
                        <li class="mb-2"><strong>Set up Ren'Py:</strong> Place your exported <code>.rpy</code> file in the <code>game</code> folder of your Ren'Py project. Make sure your image and music files are placed in the correct subfolders within Ren'Py (e.g., <code>game/images/</code> and <code>game/audio/</code>).</li>
                        <li class="mb-2"><strong>Include and Play:</strong> In your main <code>script.rpy</code> file, add the line <code>include your_exported_filename.rpy</code> to load and run the story you designed in CORE.</li>
                    </ol>
                </div>
                 <div class="help-section">
                    <h3>Appearance & Themes</h3>
                    <p>You can customize the look and feel of CORE to match your creative mood.</p>
                    <ul>
                        <li><strong>Theme Selector:</strong> In the Settings (⚙️) modal, you can choose between different visual themes.</li>
                        <li><strong>Background Controls:</strong> For themes with animated backgrounds (like Constellation), you can pause the animation or change its speed via sliders in the Settings modal. Your choices are saved locally.</li>
                        <li><strong>Canvas Helpers:</strong> You can toggle a visual grid and a non-scaling, glowing star on the canvas via the Settings panel.</li>
                    </ul>
                </div>
                <div class="help-section"><h3>Functional Shapes</h3><ul id="helpShapes"></ul></div>
                <div class="help-section"><h3>Emotional Colors</h3><ul id="helpColors"></ul></div>
                <div class="help-section"><h3>Relationship Types</h3><ul id="helpLinkTypes"></ul></div>
                <div class="help-section"><h3>Keyboard Shortcuts</h3><ul><li><code>L</code>: Toggle the list of ideas</li></ul></div>
                <div class="help-section"><h3>Chunk Types</h3><ul id="helpCoreChunks"></ul></div>
                <div class="help-section">
                    <h3>Usage, Licensing & Support</h3>
                    <p class="mb-2 text-sm">
                        <strong>Free for Indie Creators & Personal Use:</strong><br>
                        CORE Perceptual Storyteller is completely free for independent writers, narrative designers, and small game development teams to use for both personal and commercial projects. If you are creating your own story, game, or artwork, you are welcome to use this tool without charge.
                    </p>
                    <p class="mb-4 text-sm">
                        If you find it valuable, please consider supporting its development with a donation.
                    </p>

                    <p class="mb-2 text-sm">
                        <strong>License Required for Larger Teams & Institutions:</strong><br>
                        A license is required for use in larger commercial studios (e.g., "AA" or "AAA"), for integration into commercial products, or for formal academic and educational programs. This distinction protects the core CORE framework for larger-scale applications while keeping this tool accessible for the indie community.
                    </p>
                    
                    <p class="text-sm">
                        For questions and licensing inquiries, please contact me at <a href="mailto:hello@thorstenbecker.de" class="text-blue-400 hover:underline">hello@thorstenbecker.de</a>.
                    </p>
                    
                    <div class="my-4 flex justify-center">
                        <button id="helpDonateBtn" class="btn btn-donate inline-flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm">
                           <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" />
                            </svg>
                           <span>Donate via Ko-fi</span>
                        </button>
                    </div>

                    <p class="text-xs text-gray-500 mt-4 text-center">
                        Copyright &copy; <span class="copyrightYear"></span> <a href="https://www.thorstenbecker.de" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">Thorsten Becker</a>. All rights reserved.
                    </p>
                </div>
            </div>
            <div class="mt-6 flex justify-end"><button id="closeHelpBtn" class="btn btn-primary">OK</button></div>
        </div>
    </div>
    
    <div id="messageModal" class="modal hidden">
        <div class="modal-content max-w-lg">
            <h2 id="messageTitle" class="text-xl font-semibold mb-3 font-serif">Message</h2>
            <div id="messageText" class="mb-4 text-sm"></div>
            <div id="messageButtons" class="flex justify-end"></div>
        </div>
    </div>
    <div id="donateModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeDonateModalBtn" class="close-button">&times;</span>
            <h2 class="font-serif text-xl mb-4">Support CORE Perceptual Storyteller</h2>
            <p class="mb-4">
                Thank you for considering a donation! This project is developed and 
                maintained by an independent creator. Your support helps keep the app 
                free and growing.
            </p>
            <p>You can support the project here: <a href="https://ko-fi.com/thorstenbecker" target="_blank" rel="noopener noreferrer" class="font-bold hover:underline" style="color: var(--color-accent-gold)">Ko-fi.com/thorstenbecker</a></p>
             <div class="mt-6 flex justify-end">
                <button id="closeDonateModalOkBtn" class="btn btn-primary">OK</button>
            </div>
        </div>
    </div>

    <!-- START: New Session Restore Modal -->
    <div id="sessionRestoreModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="font-serif text-xl mb-4">Session Restored</h2>
            <p class="mb-4">We've restored your previous session from a secure, local browser save.</p>
            <div class="mt-6 flex justify-end">
                <button id="restoreStartFreshBtn" class="btn btn-secondary">Start Fresh</button>
                <button id="restoreContinueBtn" class="btn btn-primary">Continue</button>
            </div>
        </div>
    </div>
    <!-- END: New Session Restore Modal -->

    <input type="file" id="fileLoadInput" class="hidden" accept=".json,application/json">
    <input type="file" id="templateLoadInput" class="hidden" accept=".chtml,application/json">


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Constants & Definitions ---
        const AUTOSAVE_KEY = 'chorusAutoSaveData';
        const DEFAULT_CHUNK_TYPES = {
            perception: [ { tag: "#Sensory-Cue", description: "Something a character sees, hears, smells, etc." }, { tag: "#Environmental-Detail", description: "A feature of the setting or atmosphere." }, { tag: "#Object-Focus", description: "A specific, meaningful object." } ],
            emotion: [ { tag: "#Emotional-Beat", description: "A clear expression of a feeling." }, { tag: "#Internal-Feeling", description: "A character's private, inner emotion." }, { tag: "#Mood-Shift", description: "A change in the emotional atmosphere." } ],
            cognition: [ { tag: "#Character-Insight", description: "A realization or dawning awareness." }, { tag: "#Memory", description: "A flashback or recollection." }, { tag: "#Internal-Monologue", description: "A character's direct thoughts." } ],
            action: [ { tag: "#Decision-Point", description: "A moment where a character must choose." }, { tag: "#Character-Action", description: "A physical action taken by a character." }, { tag: "#Consequence", description: "The result of a previous action or event." } ]
        };
        const SHAPES = [
            { name: "Circle",   symbol: "◯", essence: "Internal Feeling/Thought", svg: `<circle cx="7" cy="7" r="6" />`},
            { name: "Square",   symbol: "□", essence: "External Cue/Observation", svg: `<rect x="1" y="1" width="12" height="12" />`},
            { name: "Triangle", symbol: "△", essence: "Shift/Change in Perception", svg: `<path d="M7 1 L13 13 L1 13 Z" />`},
            { name: "Diamond",  symbol: "◇", essence: "Core Insight/Realization", svg: `<path d="M7 1 L13 7 L7 13 L1 7 Z" />`},
            { name: "Arrow",    symbol: "→", essence: "Action/Decision", svg: `<path d="M1 7 L11 7 M8 4 L11 7 L8 10" />`}
        ];
        const COLORS = [ 
            { name: "White",   symbol: "⚪", essence: "Open, Uncategorized", hex: "#f8fafc", linkColor: "#a0a0c0" },
            { name: "Red",     symbol: "🔴", essence: "Conflict, Danger, Tension", hex: "#fecaca", linkColor: "#ef4444" }, 
            { name: "Blue",    symbol: "🔵", essence: "Reflection, Sadness, Calm", hex: "#bfdbfe", linkColor: "#60a5fa" }, 
            { name: "Green",   symbol: "🟢", essence: "Growth, Positive Outcome", hex: "#bbf7d0", linkColor: "#4ade80" }, 
            { name: "Yellow",  symbol: "🟡", essence: "Discovery, Hope, Key Insight", hex: "#fef08a", linkColor: "#facc15" }, 
            { name: "Purple",  symbol: "🟣", essence: "Mystery, Intrigue, Subconscious", hex: "#e9d5ff", linkColor: "#c084fc" }, 
            { name: "Grey",    symbol: "🩶", essence: "Exposition, Neutral Observation", hex: "#e5e7eb", linkColor: "#9ca3af" },
            { name: "Black",   symbol: "⚫", essence: "Finality, Consequence, Trauma", hex: "#64748b", linkColor: "#94a3b8" } // Updated Black for better dark theme appearance
        ];
        const LINK_TYPES = [
            { type: "triggers", label: "Triggers (Cause & Effect)", style: "solid" },
            { type: "reveals", label: "Reveals (Uncovers Information)", style: "dashed" },
            { type: "echoes", label: "Echoes (Thematic/Symbolic Link)", style: "dotted" },
            { type: "contrasts", label: "Contrasts (Opposition/Duality)", style: "complex-dash" }
        ];
        const NARRATIVE_TEMPLATES = {
            thresholdMoment: {
                name: "The Threshold Moment",
                description: "A character's perception before and after a key event.",
                chunks: [ 
                    {id: "a1", x:100, y:250, w:250, h:150, type: "#Environmental-Detail", shape: "Square", color: "Grey", text: "Before: The room is just a room. Clinical and quiet."}, 
                    {id: "a2", x:450, y:250, w:250, h:150, type: "#Sensory-Cue", shape: "Triangle", color: "Red", text: "The Trigger: A discordant chime echoes from a hidden speaker."}, 
                    {id: "a3", x:800, y:150, w:250, h:150, type: "#Mood-Shift", shape: "Circle", color: "Blue", text: "After: The quiet is no longer calm, but menacing. Every shadow seems to lengthen."},
                    {id: "a4", x:800, y:350, w:250, h:150, type: "#Character-Insight", shape: "Diamond", color: "Yellow", text: "Realization: 'This isn't a hospital. It's a prison.'"}
                ],
                links: [ 
                    { from: "a1", to: "a2", type: "triggers" }, 
                    { from: "a2", to: "a3", type: "triggers", label: "causes" },
                    { from: "a2", to: "a4", type: "reveals", label: "leads to" }
                ]
            },
            hauntedMemory: {
                name: "The Haunted Memory",
                description: "An external cue triggers a memory, coloring present perception.",
                chunks: [ 
                    {id: "h1", x:100, y:200, w:250, h:150, type: "#Object-Focus", shape: "Square", color: "Grey", text: "A cracked porcelain doll sits on the shelf."}, 
                    {id: "h2", x:450, y:200, w:250, h:150, type: "#Memory", shape: "Circle", color: "Purple", text: "Flashback: A memory of a childhood friend, lost long ago, who owned a similar doll."}, 
                    {id: "h3", x:800, y:200, w:250, h:150, type: "#Internal-Feeling", shape: "Circle", color: "Blue", text: "A wave of unexpected sadness and longing washes over the character."} 
                ],
                links: [ 
                    { from: "h1", to: "h2", type: "triggers", label: "triggers"}, 
                    { from: "h2", to: "h3", type: "echoes", label: "colors the present"}
                ]
            },
            visualNovelScene: {
                name: "Visual Novel Scene",
                description: "A simple branching dialogue choice.",
                chunks: [
                    { id: "vn1", x: 100, y: 250, w: 280, h: 160, type: "#Character-Action", shape: "Square", color: "Grey", text: "Yuki looks at you, a curious glint in her eyes. \"Have you ever wondered what lies beyond the city walls?\"" },
                    { id: "vn2", x: 480, y: 250, w: 280, h: 160, type: "#Decision-Point", shape: "Arrow", color: "Yellow", text: "What do you say?" },
                    { id: "vn3", x: 860, y: 150, w: 280, h: 160, type: "#Internal-Monologue", shape: "Circle", color: "Green", text: "(Choice A) \"All the time. I dream of adventure out there.\"" },
                    { id: "vn4", x: 860, y: 350, w: 280, h: 160, type: "#Internal-Monologue", shape: "Circle", color: "Blue", text: "(Choice B) \"Everything I care about is right here.\"" }
                ],
                links: [
                    { from: "vn1", to: "vn2", type: "triggers" },
                    { from: "vn2", to: "vn3", type: "reveals", label: "Optimistic" },
                    { from: "vn2", to: "vn4", type: "reveals", label: "Cautious" }
                ]
            },
            pointAndClickPuzzle: {
                name: "Point & Click Puzzle",
                description: "A classic inventory-based puzzle.",
                chunks: [
                    { id: "pc1", x: 100, y: 150, w: 250, h: 150, type: "#Environmental-Detail", shape: "Square", color: "Grey", text: "A rusty, old safe is bolted to the floor. It looks like it hasn't been opened in decades." },
                    { id: "pc2", x: 100, y: 350, w: 250, h: 150, type: "#Object-Focus", shape: "Square", color: "Purple", text: "Tucked under a loose floorboard, you find a weirdly-shaped key." },
                    { id: "pc3", x: 450, y: 250, w: 250, h: 150, type: "#Decision-Point", shape: "Diamond", color: "Yellow", text: "Use the weirdly-shaped key on the rusty safe." },
                    { id: "pc4", x: 800, y: 250, w: 250, h: 150, type: "#Consequence", shape: "Triangle", color: "Green", text: "With a loud *clunk*, the safe opens! Inside is a mysterious diary." }
                ],
                links: [
                    { from: "pc1", to: "pc3", type: "triggers", label: "is target" },
                    { from: "pc2", to: "pc3", type: "triggers", label: "is used" },
                    { from: "pc3", to: "pc4", type: "reveals", label: "results in" }
                ]
            }
        };
        const ICON_PENCIL_EDIT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`;
        const ICON_LINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
        const ICON_LINKING_ACTIVE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
        const ICON_DELETE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>`;
        const ICON_AI_SPARKLE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.25 10.5l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5ZM16.5 3.75l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5Z" /></svg>`;

        // --- DOM Elements Cache ---
        const noteCanvasContainer = document.getElementById('noteCanvasContainer'); const transformContainer = document.getElementById('transformContainer'); const svgCanvas = document.getElementById('svgCanvas'); const noteCanvas = document.getElementById('noteCanvas'); const addChunkBtn = document.getElementById('addChunkBtn'); const templatesBtn = document.getElementById('templatesBtn'); const templatesModal = document.getElementById('templatesModal'); const templateList = document.getElementById('templateList'); const clearCanvasBtn = document.getElementById('clearCanvasBtn'); const undoDeleteBtn = document.getElementById('undoDeleteBtn'); const chunkCountDisplay = document.getElementById('chunkCountDisplay'); const addChunkModal = document.getElementById('addChunkModal'); const chunkTypeSelect = document.getElementById('chunkTypeSelect'); const addChunkShapeSelect = document.getElementById('addChunkShapeSelect'); const addChunkColorSelect = document.getElementById('addChunkColorSelect'); const confirmAddChunkBtn = document.getElementById('confirmAddChunkBtn'); const cancelAddChunkBtn = document.getElementById('cancelAddChunkBtn'); const editChunkModal = document.getElementById('editChunkModal'); const editingChunkIdInput = document.getElementById('editingChunkId'); const editChunkTypeSelect = document.getElementById('editChunkTypeSelect'); const editChunkShapeSelect = document.getElementById('editChunkShapeSelect'); const editChunkColorSelect = document.getElementById('editChunkColorSelect'); const confirmEditChunkBtn = document.getElementById('confirmEditChunkBtn'); const cancelEditChunkBtn = document.getElementById('cancelEditChunkBtn'); const helpBtn = document.getElementById('helpBtn'); const helpModal = document.getElementById('helpModal'); const closeHelpBtn = document.getElementById('closeHelpBtn'); const closeHelpModalSpan = document.getElementById('closeHelpModalSpan'); const saveBtn = document.getElementById('saveBtn'); const loadBtn = document.getElementById('loadBtn'); const fileLoadInput = document.getElementById('fileLoadInput'); const messageModal = document.getElementById('messageModal'); const messageTitle = document.getElementById('messageTitle'); const messageText = document.getElementById('messageText'); const messageButtons = document.getElementById('messageButtons');
        const unlinkModal = document.getElementById('unlinkModal'); const unlinkList = document.getElementById('unlinkList'); const closeUnlinkModalBtn = document.getElementById('closeUnlinkModalBtn');
        const exportBtn = document.getElementById('exportBtn'); const exportDropdownContent = document.getElementById('exportDropdownContent');
        const linkEditModal = document.getElementById('linkEditModal'); const linkEditTitle = document.getElementById('linkEditTitle'); const linkTypeSelect = document.getElementById('linkTypeSelect'); const linkLabelInput = document.getElementById('linkLabelInput'); const cancelLinkEditBtn = document.getElementById('cancelLinkEditBtn'); const confirmLinkEditBtn = document.getElementById('confirmLinkEditBtn'); const linkSourceIdInput = document.getElementById('linkSourceId'); const linkTargetIdInput = document.getElementById('linkTargetId');
        const saveCanvasAsTemplateBtn = document.getElementById('saveCanvasAsTemplateBtn'); const loadCustomTemplateBtn = document.getElementById('loadCustomTemplateBtn'); const templateLoadInput = document.getElementById('templateLoadInput');
        const settingsBtn = document.getElementById('settingsBtn'); const settingsModal = document.getElementById('settingsModal'); const closeSettingsModalBtn = document.getElementById('closeSettingsModalBtn'); const saveSettingsBtn = document.getElementById('saveSettingsBtn'); const geminiApiKeyInput = document.getElementById('geminiApiKeyInput'); const bgAnimationToggle = document.getElementById('bgAnimationToggle'); const bgAnimationSpeed = document.getElementById('bgAnimationSpeed'); const themeSelect = document.getElementById('themeSelect'); const gridToggle = document.getElementById('gridToggle'); const centerStarToggle = document.getElementById('centerStarToggle');
        const aiActionModal = document.getElementById('aiActionModal'); const aiActionDeepenBtn = document.getElementById('aiActionDeepenBtn'); const aiActionInternalStateBtn = document.getElementById('aiActionInternalStateBtn'); const aiActionSuggestEchoBtn = document.getElementById('aiActionSuggestEchoBtn');
        const zoomInBtn = document.getElementById('zoomInBtn'); const zoomOutBtn = document.getElementById('zoomOutBtn'); const zoomResetBtn = document.getElementById('zoomResetBtn');
        const chunkListToggleBtn = document.getElementById('chunkListToggleBtn'); const chunkListPanel = document.getElementById('chunkListPanel'); const chunkListContainer = document.getElementById('chunkListContainer');
        const donateBtn = document.getElementById('donateBtn'); const donateModal = document.getElementById('donateModal'); const closeDonateModalBtn = document.getElementById('closeDonateModalBtn'); const closeDonateModalOkBtn = document.getElementById('closeDonateModalOkBtn'); const helpDonateBtn = document.getElementById('helpDonateBtn');
        // START: New DOM elements for auto-save feature
        const sessionRestoreModal = document.getElementById('sessionRestoreModal');
        const restoreContinueBtn = document.getElementById('restoreContinueBtn');
        const restoreStartFreshBtn = document.getElementById('restoreStartFreshBtn');
        // END: New DOM elements

        // --- App State ---
        let chunkTypes = {}; let allChunkTypesList = []; let chunks = []; let chunksMap = new Map();
        let highestZIndex = 1; let draggedChunk = null; let resizingChunk = null; let interactionStartX = 0; let interactionStartY = 0; let offsetX = 0; let offsetY = 0; let startX = 0; let startY = 0; let startWidth = 0; let startHeight = 0; let selectedChunkId = null; let linkingMode = false; let linkingSourceChunkId = null; let lastDeletedChunk = null;
        let scale = 1; let translateX = 0; let translateY = 0; const MIN_SCALE = 0.1; const MAX_SCALE = 3.0; const ZOOM_SENSITIVITY = 0.001;
        let currentAction = null; let panStartX = 0; let panStartY = 0; let initialPinchDistance = null; let transformUpdateQueued = false;
        let geminiApiKey = null; let activeAiChunkId = null;
        let appSettings = {};

        // --- START: Auto-Save Functions ---
        /**
         * Saves the entire state of the canvas (chunks and viewport) to the browser's local storage.
         * This function is the core of the auto-save feature.
         */
        function saveStateToLocalStorage() {
            // A simple guard to prevent saving an empty canvas after clearing, which would
            // overwrite a potentially valid save from another tab. Instead, we explicitly clear.
            if (chunks.length === 0) {
                clearAutoSave();
                return;
            }

            try {
                // First, ensure all text content from contentEditable divs is synced to the data model.
                chunks.forEach(chunkData => {
                    const chunkElement = document.getElementById(chunkData.id);
                    if (chunkElement) {
                        const contentDiv = chunkElement.querySelector('.chunk-content');
                        if (contentDiv) {
                            chunkData.text = contentDiv.innerHTML;
                        }
                    }
                });

                const dataToSave = {
                    chunks: chunks,
                    viewport: {
                        scale: scale,
                        translateX: translateX,
                        translateY: translateY
                    },
                    timestamp: new Date().toISOString() // Good practice to timestamp saves
                };
                localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(dataToSave));
            } catch (error) {
                console.error("Auto-save error:", error);
                // Inform the user if local storage is full or fails.
                showMessage('Auto-Save Error', `Could not automatically save your work to the browser's local storage. You may be out of space. Error: ${error.message}`);
            }
        }

        /**
         * Removes the auto-saved data from local storage.
         */
        function clearAutoSave() {
            localStorage.removeItem(AUTOSAVE_KEY);
        }
        // --- END: Auto-Save Functions ---


        // --- Utility & Setup Functions ---
        function generateId() { return 'chunk_' + Date.now() + '-' + Math.random().toString(36).substring(2, 9); }
        function showModal(modalElement) { modalElement.classList.remove('hidden'); }
        function hideModal(modalElement) { modalElement.classList.add('hidden'); }
        function showMessage(title, text, buttonsConfig = [{ text: 'OK', class: 'btn-primary', action: () => hideModal(messageModal) }]) {
            messageTitle.textContent = title; messageText.innerHTML = text; messageButtons.innerHTML = '';
            buttonsConfig.forEach(btnConfig => {
                const button = document.createElement('button');
                button.className = `btn ${btnConfig.class || 'btn-secondary'}`; button.textContent = btnConfig.text;
                button.onclick = () => { if (btnConfig.action) btnConfig.action(); if (!btnConfig.noHide) hideModal(messageModal); };
                messageButtons.appendChild(button);
            });
            showModal(messageModal);
        }
        function updateChunkCounter() { chunkCountDisplay.textContent = `Ideas: ${chunks.length}`; }

        function populateSelectWithOptions(selectElement, optionsArray, currentValue, groups = null, groupLabelFormatterFn = null) {
            selectElement.innerHTML = '';
            if (groups && groupLabelFormatterFn) {
                 for (const groupKey in groups) {
                    if (groups.hasOwnProperty(groupKey) && groups[groupKey].length > 0) {
                        const groupItems = groups[groupKey];
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = groupLabelFormatterFn(groupKey);
                        groupItems.forEach(item => {
                            const option = document.createElement('option');
                            option.value = item.tag; option.textContent = `${item.tag} - ${item.description}`;
                            if (item.tag === currentValue) option.selected = true;
                            optgroup.appendChild(option);
                        });
                        selectElement.appendChild(optgroup);
                    }
                }
            } else if (optionsArray) {
                optionsArray.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value; option.textContent = opt.text;
                    if (opt.value === currentValue) option.selected = true;
                    selectElement.appendChild(option);
                });
            }
        }
        
        /**
         * Determines if a color is light or dark.
         * @param {string} hex - The hex color code (e.g., "#RRGGBB").
         * @returns {boolean} - True if the color is light, false if dark.
         */
        function isColorLight(hex) {
            if (!hex) return true;
            let r, g, b;
            if (hex.startsWith('#')) { hex = hex.slice(1); }
            if (hex.length === 3) {
                r = parseInt(hex.charAt(0).repeat(2), 16);
                g = parseInt(hex.charAt(1).repeat(2), 16);
                b = parseInt(hex.charAt(2).repeat(2), 16);
            } else if (hex.length === 6) {
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
            } else {
                return true; // Default for invalid format
            }
            // Using the HSP value formula http://alienryderflex.com/hsp.html
            const hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));
            return hsp > 127.5;
        }

        function populateHelpModal() {
            allChunkTypesList = Object.values(chunkTypes).flat();
            document.getElementById('helpShapes').innerHTML = SHAPES.map(s => `<li><span class="font-bold">${s.symbol} ${s.name}</span>: ${s.essence}</li>`).join('');
            document.getElementById('helpColors').innerHTML = COLORS.map(c => `<li><span class="font-bold">${c.symbol} ${c.name}</span>: ${c.essence}</li>`).join('');
            document.getElementById('helpLinkTypes').innerHTML = LINK_TYPES.map(l => `<li><span class="font-bold">${l.label}</span>: Use for showing how chunks influence each other.</li>`).join('');
            document.getElementById('helpCoreChunks').innerHTML = allChunkTypesList.map(c => `<li><code>${c.tag}</code>: ${c.description}</li>`).join('');
        }

        function populateAddChunkModal() { 
            populateSelectWithOptions(chunkTypeSelect, null, null, chunkTypes, key => key.charAt(0).toUpperCase() + key.slice(1) + " Types"); 
            populateSelectWithOptions(addChunkShapeSelect, SHAPES.map(shape => ({value: shape.name, text: `${shape.symbol} ${shape.name} - ${shape.essence}`})), "Square");
            populateSelectWithOptions(addChunkColorSelect, COLORS.map(c => ({value: c.name, text: `${c.symbol} ${c.name} - ${c.essence}`})), "White");
        }
        
        // --- Custom Chunk Type Management ---
        function loadCustomChunkTypes() {
            // Simplified for this version - always uses default
            chunkTypes = JSON.parse(JSON.stringify(DEFAULT_CHUNK_TYPES)); 
            allChunkTypesList = Object.values(chunkTypes).flat();
            populateHelpModal();
        }

        // --- Canvas Helpers (Grid & Markers) ---
        function createCanvasHelpers() {
            const defs = svgCanvas.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            if (!svgCanvas.contains(defs)) {
                svgCanvas.insertBefore(defs, svgCanvas.firstChild);
            }

            // Grid Pattern
            if (!document.getElementById('gridPattern')) {
                const gridPattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                gridPattern.id = 'gridPattern';
                gridPattern.setAttribute('width', '100');
                gridPattern.setAttribute('height', '100');
                gridPattern.setAttribute('patternUnits', 'userSpaceOnUse');
                const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                gridPath.setAttribute('d', 'M 100 0 L 0 0 0 100');
                gridPattern.appendChild(gridPath);
                defs.appendChild(gridPattern);
            }

            // Grid Rectangle
            if (!document.getElementById('canvasGrid')) {
                const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                gridGroup.id = 'canvasGrid';
                const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                gridRect.setAttribute('width', '100%');
                gridRect.setAttribute('height', '100%');
                gridRect.setAttribute('fill', 'url(#gridPattern)');
                gridGroup.appendChild(gridRect);
                svgCanvas.appendChild(gridGroup);
            }
            
            // New Glowing Center Star
            if (!document.getElementById('canvasCenterStar')) {
                const centerStarGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                centerStarGroup.id = 'canvasCenterStar';
                const starPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                // A 6-pointed star path, scaled up by 1.5x
                starPath.setAttribute('d', 'M22.5 0 L27.75 16.5 H43.5 L31.5 26.25 L36 43.5 L22.5 33 L9 43.5 L13.5 26.25 L1.5 16.5 H17.25 Z');
                centerStarGroup.appendChild(starPath);
                svgCanvas.appendChild(centerStarGroup);
            }
        }

        // --- Settings Management ---
        function loadSettings() {
            const savedSettings = localStorage.getItem('chorusAppSettings');
            appSettings = savedSettings ? JSON.parse(savedSettings) : {
                geminiApiKey: null,
                theme: 'light',
                bgAnimationOn: true,
                bgAnimationSpeed: 200,
                showGrid: false,
                showCenterStar: false // New setting default
            };
            geminiApiKey = appSettings.geminiApiKey;
            if (geminiApiKey) { geminiApiKeyInput.value = geminiApiKey; }
            
            populateSelectWithOptions(themeSelect, [
                { value: 'dark', text: 'Constellation (Dark)' },
                { value: 'light', text: 'Parchment (Light)' },
                { value: 'sketch', text: 'Pencil (Legible)' },
                { value: 'visual-novel', text: 'Visual Novel' },
                { value: 'final-fantasy', text: 'RPG Menu (Fantasy)' },
                { value: 'point-and-click', text: 'Retro Adventure' },
            ], appSettings.theme);
            
            bgAnimationToggle.checked = appSettings.bgAnimationOn;
            bgAnimationSpeed.value = appSettings.bgAnimationSpeed;
            gridToggle.checked = appSettings.showGrid;
            centerStarToggle.checked = appSettings.showCenterStar; // Load star setting
            
            applySettings();
        }

        function saveSettings() {
            appSettings.geminiApiKey = geminiApiKeyInput.value.trim();
            appSettings.theme = themeSelect.value;
            appSettings.bgAnimationOn = bgAnimationToggle.checked;
            appSettings.bgAnimationSpeed = bgAnimationSpeed.value;
            appSettings.showGrid = gridToggle.checked;
            appSettings.showCenterStar = centerStarToggle.checked; // Save star setting

            localStorage.setItem('chorusAppSettings', JSON.stringify(appSettings));
            geminiApiKey = appSettings.geminiApiKey;
            
            applySettings();
            showMessage("Settings Saved", "Your settings have been saved.");
        }

        function applySettings() {
            document.body.dataset.theme = appSettings.theme || 'light';
            
            const rootStyle = document.documentElement.style;
            const isAnimatableTheme = ['dark', 'final-fantasy'].includes(document.body.dataset.theme);
            rootStyle.setProperty('--bg-anim-play-state', appSettings.bgAnimationOn && isAnimatableTheme ? 'running' : 'paused');
            rootStyle.setProperty('--bg-anim-duration', `${410 - appSettings.bgAnimationSpeed}s`);
            bgAnimationToggle.disabled = !isAnimatableTheme;
            bgAnimationSpeed.disabled = !appSettings.bgAnimationOn || !isAnimatableTheme;

            document.body.classList.toggle('grid-visible', appSettings.showGrid);
            document.body.classList.toggle('center-star-visible', appSettings.showCenterStar); // Apply star visibility
        }
       
        // --- Template Management ---
        function setupTemplateModal() {
            templateList.innerHTML = '';
            for (const key in NARRATIVE_TEMPLATES) {
                const template = NARRATIVE_TEMPLATES[key];
                const btn = document.createElement('button');
                btn.className = 'btn btn-secondary w-full text-left justify-start';
                btn.innerHTML = `<div><div class="font-bold font-serif">${template.name}</div><div class="text-sm font-normal text-gray-400">${template.description}</div></div>`;
                btn.onclick = () => {
                    showMessage("Confirm Load Template", `This will clear the current canvas. Are you sure you want to load the "${template.name}" template?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load Template', class: 'btn-primary', action: () => { loadTemplate(template); hideModal(templatesModal); } } ]);
                };
                templateList.appendChild(btn);
            }
        }
        function loadTemplate(template) {
            if (!template || !template.chunks) return;
            renderBoard([]); 
            const loadedChunksData = [];
            const idMap = new Map();
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            template.chunks.forEach(chunkTmpl => {
                minX = Math.min(minX, chunkTmpl.x); minY = Math.min(minY, chunkTmpl.y);
                maxX = Math.max(maxX, chunkTmpl.x + (chunkTmpl.w || 250)); maxY = Math.max(maxY, chunkTmpl.y + (chunkTmpl.h || 150));
            });
            const templateWidth = maxX - minX; const templateHeight = maxY - minY;
            const viewportRect = noteCanvasContainer.getBoundingClientRect();
            const viewportCenterX = viewportRect.width / 2; const viewportCenterY = viewportRect.height / 2;
            const worldCenter = screenToWorld(viewportCenterX, viewportCenterY);
            const offsetX = worldCenter.x - (minX + templateWidth / 2); const offsetY = worldCenter.y - (minY + templateHeight / 2);

            template.chunks.forEach(chunkTmpl => {
                const chunkType = allChunkTypesList.find(ct => ct.tag === chunkTmpl.type);
                if(!chunkType) { console.warn("Skipping template chunk with invalid type:", chunkTmpl); return; }
                const newId = generateId(); if(chunkTmpl.id) idMap.set(chunkTmpl.id, newId);
                const newChunkData = {
                    id: newId, chunkTypeTag: chunkTmpl.type, shape: chunkTmpl.shape || "Square", color: chunkTmpl.color || "White", text: chunkTmpl.text || '...',
                    x: (chunkTmpl.x || 0) + offsetX, y: (chunkTmpl.y || 0) + offsetY, width: chunkTmpl.w || 250, height: chunkTmpl.h || 150, zIndex: ++highestZIndex, links: [] 
                };
                loadedChunksData.push(newChunkData);
            });

            if (template.links) {
                template.links.forEach(link => {
                    const sourceId = idMap.get(link.from); const targetId = idMap.get(link.to);
                    const sourceChunk = loadedChunksData.find(c => c.id === sourceId);
                    if(sourceChunk && targetId) { sourceChunk.links.push({ targetId, label: link.label || '', type: link.type || 'triggers' }); }
                });
            }
            renderBoard(loadedChunksData);
            populateChunkList();
            saveStateToLocalStorage();
        }

        // --- Transform and Coordinate Functions ---
        function applyTransform() { 
            if (!transformUpdateQueued) { 
                transformUpdateQueued = true; 
                requestAnimationFrame(() => { 
                    transformContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; 
                    svgCanvas.setAttribute('width', String(noteCanvas.scrollWidth)); 
                    svgCanvas.setAttribute('height', String(noteCanvas.scrollHeight)); 
                    
                    // Update center star to counteract scaling
                    const centerStar = document.getElementById('canvasCenterStar');
                    if (centerStar) {
                        const canvasCenterX = noteCanvas.scrollWidth / 2;
                        const canvasCenterY = noteCanvas.scrollHeight / 2;
                        // The bigger star's path is drawn in a ~44x44 box, so we translate by half to center it.
                        centerStar.setAttribute('transform', `translate(${canvasCenterX}, ${canvasCenterY}) scale(${1 / scale}) translate(-22.5, -21.75)`);
                    }

                    drawConnections(); 
                    transformUpdateQueued = false; 
                }); 
            } 
        }
        function zoomAtPoint(newScale, pointX, pointY) {
            newScale = Math.max(MIN_SCALE, Math.min(newScale, MAX_SCALE));
            const worldXBeforeZoom = (pointX - translateX) / scale;
            const worldYBeforeZoom = (pointY - translateY) / scale;
            translateX = pointX - worldXBeforeZoom * newScale;
            translateY = pointY - worldYBeforeZoom * newScale;
            scale = newScale;
            applyTransform();
        }
        function resetAndCenterView() { scale = 1; const viewportWidth = noteCanvasContainer.clientWidth; const viewportHeight = noteCanvasContainer.clientHeight; const canvasContentWidth = noteCanvas.scrollWidth; const canvasContentHeight = noteCanvas.scrollHeight; translateX = (viewportWidth - canvasContentWidth * scale) / 2; translateY = (viewportHeight - canvasContentHeight * scale) / 2; applyTransform(); }
        function screenToWorld(screenX, screenY) { const containerRect = noteCanvasContainer.getBoundingClientRect(); const rectLeft = containerRect.left || 0; const rectTop = containerRect.top || 0; const worldX = (screenX - rectLeft - translateX) / scale; const worldY = (screenY - rectTop - translateY) / scale; return { x: worldX, y: worldY }; }
        function getPointerCoordinates(e) { if (e.touches && e.touches.length > 0) { return { x: e.touches[0].clientX, y: e.touches[0].clientY, count: e.touches.length }; } return { x: e.clientX, y: e.clientY, count: e.buttons === 1 ? 1 : 0 }; }
        function centerOnChunk(chunkId, setScaleToOne = true) {
            const chunkData = chunksMap.get(chunkId);
            if (!chunkData) return;
            if (setScaleToOne) { scale = 1; }
            const viewportWidth = noteCanvasContainer.clientWidth;
            const viewportHeight = noteCanvasContainer.clientHeight;
            const chunkCenterX = chunkData.x + chunkData.width / 2;
            const chunkCenterY = chunkData.y + chunkData.height / 2;
            translateX = (viewportWidth / 2) - (chunkCenterX * scale);
            translateY = (viewportHeight / 2) - (chunkCenterY * scale);
            applyTransform();
        }

        // --- Gemini AI Functions ---
        const originalButtonStates = {};
        function setButtonLoading(button, isLoading) { if (!button) { return; } const buttonId = button.id || `btn-${Math.random()}`; button.id = buttonId; if (isLoading) { if (!originalButtonStates[buttonId]) { originalButtonStates[buttonId] = button.innerHTML; } button.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`; button.disabled = true; } else { if (originalButtonStates[buttonId] !== undefined) { button.innerHTML = originalButtonStates[buttonId]; delete originalButtonStates[buttonId]; } button.disabled = false; } }
        
        async function callGemini(prompt, buttonToLoad) { 
            if (!geminiApiKey) { 
                showMessage("API Key Required", "Please enter your Google AI API key in the Settings modal first.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Open Settings', class: 'btn-primary', action: () => showModal(settingsModal) } ]); 
                return null; 
            } 
            if (buttonToLoad) setButtonLoading(buttonToLoad, true); 
            
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`; 
            
            try { 
                const response = await fetch(API_URL, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                }); 
                
                if (!response.ok) { 
                    const errorData = await response.json(); 
                    throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`); 
                } 
                
                const data = await response.json(); 
                
                if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) { 
                    return data.candidates[0].content.parts[0].text; 
                } else { 
                    if(data.candidates && data.candidates[0].finishReason === 'SAFETY') { 
                        throw new Error("The response was blocked due to safety settings. Please adjust your prompt."); 
                    } 
                    throw new Error("Received an empty or invalid response from the AI."); 
                } 
            } catch (error) { 
                showMessage("AI Error", `An error occurred: ${error.message}`); 
                console.error("Gemini API call failed:", error); 
                return null; 
            } finally { 
                if (buttonToLoad) setButtonLoading(buttonToLoad, false); 
            } 
        }

        function openAiModal(chunkId) { 
            if (!geminiApiKey) { 
                showMessage("API Key Required", "Please enter your Google AI API key in the Settings modal first.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Open Settings', class: 'btn-primary', action: () => { hideModal(aiActionModal); showModal(settingsModal); } } ]); 
                return; 
            } 
            activeAiChunkId = chunkId; 
            showModal(aiActionModal); 
        }

        async function handleDeepenSensoryDetails() {
            const chunkData = chunksMap.get(activeAiChunkId);
            if (!chunkData) { return; }
            const contentDiv = document.getElementById(activeAiChunkId)?.querySelector('.chunk-content');
            if(!contentDiv) return;
            const prompt = `Given the following narrative beat, expand on it with richer sensory details (sight, sound, smell, touch, internal bodily feelings). Respond only with the new, enhanced text, not with conversational phrases. CONTEXT: "${contentDiv.innerText}"`;
            const result = await callGemini(prompt, aiActionDeepenBtn);
            if (result) {
                let htmlResult = result.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>'); 
                htmlResult = `<p>${htmlResult}</p>`;
                contentDiv.innerHTML = htmlResult; 
                chunkData.text = htmlResult; 
                hideModal(aiActionModal);
                saveStateToLocalStorage();
                showMessage("Idea Deepened", "The idea's content has been enhanced with sensory details.");
            }
        }
        
        async function handleExploreInternalState() {
            const sourceChunkData = chunksMap.get(activeAiChunkId);
            if (!sourceChunkData) { return; }
            const contentDiv = document.getElementById(activeAiChunkId)?.querySelector('.chunk-content');
            if(!contentDiv) return;
            const prompt = `An external event or observation is described as: "${contentDiv.innerText}". Suggest a plausible internal thought or feeling for a character experiencing this. Respond with only the text for the new thought or feeling.`;
            const newText = await callGemini(prompt, aiActionInternalStateBtn);
            if (newText) {
                const newChunkDetails = {
                    type: allChunkTypesList.find(ct => ct.tag === "#Internal-Feeling") || allChunkTypesList[0],
                    shape: "Circle",
                    color: "Purple"
                };
                const newChunkOptions = {
                    text: `<p>${newText.replace(/\n/g, '<br>')}</p>`,
                    x: sourceChunkData.x + sourceChunkData.width + 40,
                    y: sourceChunkData.y
                };
                const newChunkData = addChunkToCanvas(newChunkDetails, newChunkOptions);
                addOrUpdateLink(sourceChunkData.id, newChunkData.id, "reveals", "reveals");
                centerOnChunk(newChunkData.id, true);
                hideModal(aiActionModal);
                showMessage("Internal State Explored", "A new idea has been created and linked to represent the character's internal state.");
            }
        }
        
        async function handleSuggestEcho() {
            const sourceChunkData = chunksMap.get(activeAiChunkId);
            if (!sourceChunkData) { return; }
            const contentDiv = document.getElementById(activeAiChunkId)?.querySelector('.chunk-content');
            if(!contentDiv) return;
            const prompt = `The following is a moment in a story: "${contentDiv.innerText}". Suggest a different, separate moment that thematically or emotionally *echoes* this one. It could be a memory, a symbol, or a future event that rhymes with this one. Respond with only the text for the new moment.`;
            const newText = await callGemini(prompt, aiActionSuggestEchoBtn);
             if (newText) {
                const newChunkDetails = {
                    type: allChunkTypesList.find(ct => ct.tag === "#Memory") || allChunkTypesList[0],
                    shape: "Square",
                    color: sourceChunkData.color
                };
                const newChunkOptions = {
                    text: `<p>${newText.replace(/\n/g, '<br>')}</p>`,
                    x: sourceChunkData.x,
                    y: sourceChunkData.y + sourceChunkData.height + 40
                };
                const newChunkData = addChunkToCanvas(newChunkDetails, newChunkOptions);
                addOrUpdateLink(sourceChunkData.id, newChunkData.id, "echoes", "echoes");
                centerOnChunk(newChunkData.id, true);
                hideModal(aiActionModal);
                showMessage("Echo Suggested", "A new idea has been created with a thematically linked 'echo' moment.");
            }
        }

        // --- NEW: Chunk List Functions ---
        function toggleChunkList() {
            chunkListPanel.classList.toggle('hidden');
        }

        function populateChunkList() {
            chunkListContainer.innerHTML = '';
            if (chunks.length === 0) {
                chunkListContainer.innerHTML = `<div class="text-sm text-center text-gray-500 py-4">No ideas on canvas.</div>`;
                return;
            }
            chunks.forEach(chunkData => {
                const item = document.createElement('div');
                item.className = 'chunk-list-item';
                item.dataset.chunkId = chunkData.id;
                
                const colorInfo = COLORS.find(c => c.name === chunkData.color) || {};
                const textDiv = document.createElement('div');
                textDiv.className = 'chunk-list-item-text';
                textDiv.innerHTML = `<span class="mr-2">${colorInfo.symbol || '⚪'}</span> ${chunkData.chunkTypeTag}`;

                item.appendChild(textDiv);

                item.addEventListener('click', () => {
                    selectChunk(chunkData.id);
                    centerOnChunk(chunkData.id, false); // Don't reset zoom
                    if (!chunkListPanel.classList.contains('hidden')) {
                        toggleChunkList();
                    }
                });
                chunkListContainer.appendChild(item);
            });
            updateChunkListSelection();
        }

        function updateChunkListSelection() {
            document.querySelectorAll('.chunk-list-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.chunkId === selectedChunkId);
            });
        }

        // --- Chunk Management & Selection ---
        function updateChunkHeaderDisplay(chunkId) {
            const chunkElement = document.getElementById(chunkId);
            const chunkData = chunksMap.get(chunkId);
            if (!chunkElement || !chunkData) return;

            const header = chunkElement.querySelector('.chunk-header');
            const colorInfo = COLORS.find(c => c.name === chunkData.color) || COLORS[0];
            const shapeInfo = SHAPES.find(s => s.name === chunkData.shape) || SHAPES[0];
            
            header.style.background = colorInfo.hex;
            if (document.body.dataset.theme === 'final-fantasy') {
                header.style.background = 'none';
            }
            
            const isLight = isColorLight(colorInfo.hex);
            const textColor = isLight ? '#111827' : '#f9fafb';
            const secondaryTextColor = isLight ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.7)';

            header.style.color = textColor;
            
            const titleSpan = header.querySelector('.chunk-header-title');
            if (titleSpan) {
                titleSpan.innerHTML = `
                    <div class="chunk-header-main">
                        <span class="chunk-color-symbol" title="${colorInfo.name}: ${colorInfo.essence}">${colorInfo.symbol}</span>
                        <span class="shape-icon" title="${shapeInfo.name}: ${shapeInfo.essence}"><svg viewBox="0 0 14 14">${shapeInfo.svg}</svg></span>
                        <span>${chunkData.chunkTypeTag}</span>
                    </div>
                    <div class="chunk-functional-essence">${shapeInfo.essence}</div>
                `;
                 // Re-query for the elements just created and apply styles
                chunkElement.querySelector('.shape-icon svg').style.stroke = textColor;
                chunkElement.querySelector('.chunk-functional-essence').style.color = secondaryTextColor;
            }
        }
        function updateSelectedVisuals() { 
            document.querySelectorAll('.chorus-chunk').forEach(el => { 
                const isSelected = el.id === selectedChunkId; 
                const isLinkingSource = el.id === linkingSourceChunkId; 
                el.classList.toggle('selected-chunk', isSelected && !linkingMode); 
                el.classList.toggle('linking-source-chunk', isLinkingSource && linkingMode); 
                const linkButton = el.querySelector('.link-chunk-btn'); 
                if (linkButton) { 
                    if (isLinkingSource && linkingMode) { 
                        linkButton.innerHTML = ICON_LINKING_ACTIVE; 
                        linkButton.title = 'Cancel Linking'; 
                        linkButton.classList.add('linking-active'); 
                    } else { 
                        linkButton.innerHTML = ICON_LINK; 
                        linkButton.title = 'Add a Relationship'; 
                        linkButton.classList.remove('linking-active'); 
                    } 
                } 
            }); 
            updateChunkListSelection();
        }
        
        function selectChunk(chunkId) { 
            selectedChunkId = chunkId; 
            updateSelectedVisuals();
        }
        function deselectAllChunks() { 
            const wasLinking = linkingMode; 
            if (wasLinking) { 
                cancelLinkingMode(true); 
            } 
            selectedChunkId = null; 
            if (!wasLinking) { 
                updateSelectedVisuals(); 
            }
        }

        function createChunkElement(chunkData) {
            const chunkDiv = document.createElement('div');
            chunkDiv.id = chunkData.id; chunkDiv.className = 'chorus-chunk';
            chunkDiv.style.left = chunkData.x + 'px'; chunkDiv.style.top = chunkData.y + 'px'; chunkDiv.style.width = chunkData.width + 'px'; chunkDiv.style.height = chunkData.height + 'px'; chunkDiv.style.zIndex = String(chunkData.zIndex);
            chunkDiv.addEventListener('click', (e) => { const clickedChunkId = chunkData.id; if (linkingMode) { e.stopPropagation(); if (linkingSourceChunkId && linkingSourceChunkId !== clickedChunkId) { completeLink(linkingSourceChunkId, clickedChunkId); } else if (linkingSourceChunkId === clickedChunkId) { if (!e.target.closest('.chunk-action-btn')) { cancelLinkingMode(false); } } return; } const isInteractiveElement = e.target.closest('.chunk-action-btn') || e.target.closest('.chunk-content') || e.target.closest('.resize-handle'); if (!isInteractiveElement) { selectChunk(clickedChunkId); } });
            const header = document.createElement('div'); header.className = 'chunk-header'; header.addEventListener('mousedown', onInteractionStart); header.addEventListener('touchstart', onInteractionStart, { passive: false });
            const headerTitle = document.createElement('span'); headerTitle.className = 'chunk-header-title';
            const actionsContainer = document.createElement('div'); actionsContainer.className = 'chunk-actions';
            
            const aiBtn = document.createElement('button');
            aiBtn.className = 'chunk-action-btn ai-chunk-btn';
            aiBtn.title = 'AI Assistant';
            aiBtn.innerHTML = ICON_AI_SPARKLE;
            const handleAiButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); openAiModal(chunkData.id); };
            aiBtn.addEventListener('click', handleAiButtonAction);
            aiBtn.addEventListener('touchend', handleAiButtonAction);

            const editBtn = document.createElement('button');
            editBtn.className = 'chunk-action-btn edit-chunk-btn';
            editBtn.title = 'Edit Chunk';
            editBtn.innerHTML = ICON_PENCIL_EDIT;
            const handleEditButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); openEditChunkModal(chunkData.id); };
            editBtn.addEventListener('click', handleEditButtonAction);
            editBtn.addEventListener('touchend', handleEditButtonAction);
            
            const linkBtn = document.createElement('button');
            linkBtn.className = 'chunk-action-btn link-chunk-btn';
            linkBtn.innerHTML = ICON_LINK;
            const handleLinkButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); startLinkingMode(chunkData.id); };
            linkBtn.addEventListener('click', handleLinkButtonAction);
            linkBtn.addEventListener('touchend', handleLinkButtonAction);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'chunk-action-btn delete-chunk-btn';
            deleteBtn.title = 'Delete Chunk';
            deleteBtn.innerHTML = ICON_DELETE;
            const handleDeleteButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); deleteChunk(chunkData.id); };
            deleteBtn.addEventListener('click', handleDeleteButtonAction);
            deleteBtn.addEventListener('touchend', handleDeleteButtonAction);
            
            actionsContainer.appendChild(aiBtn);
            actionsContainer.appendChild(editBtn); 
            actionsContainer.appendChild(linkBtn); 
            actionsContainer.appendChild(deleteBtn);

            header.appendChild(headerTitle); header.appendChild(actionsContainer);
            const content = document.createElement('div'); content.className = 'chunk-content'; content.contentEditable = true; content.innerHTML = chunkData.text;
            content.addEventListener('input', () => { const currentChunkData = chunksMap.get(chunkDiv.id); if (currentChunkData) currentChunkData.text = content.innerHTML; saveStateToLocalStorage(); });
            content.addEventListener('focus', () => { highestZIndex++; chunkDiv.style.zIndex = String(highestZIndex); const currentChunkData = chunksMap.get(chunkDiv.id); if (currentChunkData) currentChunkData.zIndex = highestZIndex; if (!linkingMode) selectChunk(chunkData.id); });
            content.addEventListener('blur', () => { populateChunkList(); }); // Update list on content change
            const resizeHandle = document.createElement('div'); resizeHandle.className = 'resize-handle'; resizeHandle.addEventListener('mousedown', onInteractionStart); resizeHandle.addEventListener('touchstart', onInteractionStart, { passive: false });
            chunkDiv.appendChild(header); chunkDiv.appendChild(content); chunkDiv.appendChild(resizeHandle);
            noteCanvas.appendChild(chunkDiv);
            updateChunkHeaderDisplay(chunkData.id); updateSelectedVisuals();
            return chunkDiv;
        }
        function deleteChunk(chunkId) {
            const chunkIndex = chunks.findIndex(c => c.id === chunkId);
            if (chunkIndex > -1) {
                lastDeletedChunk = JSON.parse(JSON.stringify(chunks[chunkIndex]));
                chunks.splice(chunkIndex, 1);
                chunksMap.delete(chunkId);
                chunks.forEach(c => { if (c.links) { c.links = c.links.filter(link => link.targetId !== chunkId); } });
                undoDeleteBtn.disabled = false;
            }
            if (selectedChunkId === chunkId) deselectAllChunks();
            if (linkingSourceChunkId === chunkId) cancelLinkingMode(false);
            const chunkElement = document.getElementById(chunkId);
            if (chunkElement) noteCanvas.removeChild(chunkElement);
            drawConnections();
            updateChunkCounter();
            updateSelectedVisuals();
            populateChunkList();
            saveStateToLocalStorage();
        }
        function undoDeleteLastChunk() { if (lastDeletedChunk) { if (chunksMap.has(lastDeletedChunk.id)) { showMessage("Undo Failed", "An idea with the same ID already exists. Cannot undo."); lastDeletedChunk = null; undoDeleteBtn.disabled = true; return; } chunks.push(lastDeletedChunk); chunksMap.set(lastDeletedChunk.id, lastDeletedChunk); createChunkElement(lastDeletedChunk); drawConnections(); selectChunk(lastDeletedChunk.id); populateChunkList(); lastDeletedChunk = null; undoDeleteBtn.disabled = true; showMessage("Undo Successful", "The last deleted idea has been restored."); updateChunkCounter(); saveStateToLocalStorage(); } else { showMessage("Nothing to Undo", "No idea deletion to undo."); } }
        function addChunkToCanvas(chunkDetails, options = {}) { const viewportRect = noteCanvasContainer.getBoundingClientRect(); const defaultWorldPos = screenToWorld( (viewportRect.left || 0) + (viewportRect.width || window.innerWidth) / 2, (viewportRect.top || 0) + (viewportRect.height || window.innerHeight) / 4 ); 
		const newChunkData = { id: generateId(), chunkTypeTag: chunkDetails.type.tag, shape: chunkDetails.shape, color: chunkDetails.color, text: options.text || 'New idea...', x: options.x !== undefined ? options.x : Math.max(0, defaultWorldPos.x), y: options.y !== undefined ? options.y : Math.max(0, defaultWorldPos.y), width: options.width || 250, height: options.height || 150, zIndex: ++highestZIndex, links: [], renpy_bg: '', renpy_sprite: '', renpy_music: '' };
		    chunks.push(newChunkData);
            chunksMap.set(newChunkData.id, newChunkData);
            createChunkElement(newChunkData);
            selectChunk(newChunkData.id);
            drawConnections();
            updateChunkCounter();
            populateChunkList();
            saveStateToLocalStorage();
            return newChunkData;
        }

        // --- Linking Logic ---
        function startLinkingMode(sourceId) { linkingMode = true; linkingSourceChunkId = sourceId; document.body.classList.add('linking-mode'); selectedChunkId = sourceId; updateSelectedVisuals(); }
        function cancelLinkingMode(cancelledByDeselectAll = false) { linkingMode = false; const prevSourceId = linkingSourceChunkId; linkingSourceChunkId = null; document.body.classList.remove('linking-mode'); if (cancelledByDeselectAll) { selectedChunkId = null; } else if (prevSourceId) { selectChunk(prevSourceId); } updateSelectedVisuals(); }
        function completeLink(sourceId, targetId) {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk) return;
            openLinkEditor(sourceId, targetId);
        }
        function addOrUpdateLink(sourceId, targetId, label, linkType) {
            const sourceChunk = chunksMap.get(sourceId);
            if (sourceChunk) {
                if (!sourceChunk.links) sourceChunk.links = [];
                const existingLink = sourceChunk.links.find(l => l.targetId === targetId);
                if (existingLink) {
                    existingLink.label = label;
                    existingLink.type = linkType;
                } else {
                    sourceChunk.links.push({ targetId, label, type: linkType });
                }
            }
            drawConnections();
            updateSelectedVisuals();
            saveStateToLocalStorage();
        }
        function getIntersectionPointWithRect(rect, internalPoint, externalPoint) { const p1 = internalPoint; const p2 = externalPoint; const dx = p2.x - p1.x; const dy = p2.y - p1.y; if (dx === 0 && dy === 0) return p1; let tMin = Infinity; let intersection = null; const rectRight = rect.x + rect.width; const rectBottom = rect.y + rect.height; if (dx !== 0) { const t = (rect.x - p1.x) / dx; if (t > 1e-6) { const y = p1.y + t * dy; if (y >= rect.y && y <= rectBottom) { if (t < tMin) { tMin = t; intersection = { x: rect.x, y: y }; } } } } if (dx !== 0) { const t = (rectRight - p1.x) / dx; if (t > 1e-6) { const y = p1.y + t * dy; if (y >= rect.y && y <= rectBottom) { if (t < tMin) { tMin = t; intersection = { x: rectRight, y: y }; } } } } if (dy !== 0) { const t = (rect.y - p1.y) / dy; if (t > 1e-6) { const x = p1.x + t * dx; if (x >= rect.x && x <= rectRight) { if (t < tMin) { tMin = t; intersection = { x: x, y: rect.y }; } } } } if (dy !== 0) { const t = (rectBottom - p1.y) / dy; if (t > 1e-6) { const x = p1.x + t * dx; if (x >= rect.x && x <= rectRight) { if (t < tMin) { tMin = t; intersection = { x: x, y: rectBottom }; } } } } return intersection || p1; }
        let svgDefsCreated = false;
        function ensureSvgDefs() {
            if (svgDefsCreated) return;
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead'); marker.setAttribute('viewBox', '0 0 10 10');
            marker.setAttribute('refX', '10'); marker.setAttribute('refY', '5');
            marker.setAttribute('markerUnits', 'strokeWidth'); marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '5');
            marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); path.classList.add('arrow-head');
            marker.appendChild(path);
            defs.appendChild(marker);

            const sketchyFilter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            sketchyFilter.id = 'sketchy';
            sketchyFilter.innerHTML = `<feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="1" result="noise" />
                                     <feDisplacementMap in="SourceGraphic" in2="noise" scale="2" xChannelSelector="R" yChannelSelector="G"/>`;
            defs.appendChild(sketchyFilter);

             const sketchyGridFilter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            sketchyGridFilter.id = 'sketchy-grid';
            sketchyGridFilter.innerHTML = `<feTurbulence type="fractalNoise" baseFrequency="0.1" numOctaves="1" result="noise" />
                                         <feDisplacementMap in="SourceGraphic" in2="noise" scale="1" xChannelSelector="R" yChannelSelector="G"/>`;
            defs.appendChild(sketchyGridFilter);

            svgCanvas.appendChild(defs);
            svgDefsCreated = true;
        }
        
        function drawConnections() {
            ensureSvgDefs();
            
            const children = Array.from(svgCanvas.children);
            children.forEach(child => {
                if (child.tagName.toLowerCase() !== 'defs' && child.id !== 'canvasGrid' && child.id !== 'canvasCenterStar') {
                    svgCanvas.removeChild(child);
                }
            });

            chunks.forEach(sourceChunkData => {
                if (sourceChunkData.links && sourceChunkData.links.length > 0) {
                    sourceChunkData.links.forEach(link => {
                        const targetChunkData = chunksMap.get(link.targetId);
                        if (targetChunkData) {
                            const sourceEl = document.getElementById(sourceChunkData.id);
                            const targetEl = document.getElementById(link.targetId);
                            if (sourceEl && targetEl) {
                                const sourceRect = { x: sourceEl.offsetLeft, y: sourceEl.offsetTop, width: sourceEl.offsetWidth, height: sourceEl.offsetHeight };
                                const targetRect = { x: targetEl.offsetLeft, y: targetEl.offsetTop, width: targetEl.offsetWidth, height: targetEl.offsetHeight };
                                const sourceCenter = { x: sourceRect.x + sourceRect.width / 2, y: sourceRect.y + sourceRect.height / 2 };
                                const targetCenter = { x: targetRect.x + targetRect.width / 2, y: targetRect.y + targetRect.height / 2 };
                                if (sourceCenter.x === targetCenter.x && sourceCenter.y === targetCenter.y) return;

                                const startPoint = getIntersectionPointWithRect(sourceRect, sourceCenter, targetCenter);
                                const endPoint = getIntersectionPointWithRect(targetRect, targetCenter, sourceCenter);

                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', String(startPoint.x)); line.setAttribute('y1', String(startPoint.y));
                                line.setAttribute('x2', String(endPoint.x)); line.setAttribute('y2', String(endPoint.y));
                                line.classList.add('connecting-line');

                                const linkType = link.type || 'triggers';
                                line.classList.add(`link-type-${linkType}`);
                                
                                const sourceColorInfo = COLORS.find(c => c.name === sourceChunkData.color) || COLORS[0];
                                const linkColor = sourceColorInfo.linkColor || '#a0a0c0';
                                
                                line.style.stroke = linkColor;
                                line.setAttribute('marker-end', 'url(#arrowhead)');
                                svgCanvas.appendChild(line);
                                
                                const arrowHead = svgCanvas.querySelector(`#arrowhead path`);
                                if(arrowHead) arrowHead.style.fill = linkColor;

                                if (link.label) {
                                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                    text.setAttribute('x', String((startPoint.x + endPoint.x) / 2));
                                    text.setAttribute('y', String((startPoint.y + endPoint.y) / 2 - 5));
                                    text.classList.add('link-label');
                                    text.textContent = link.label;
                                    svgCanvas.appendChild(text);
                                }
                            }
                        }
                    });
                }
            });
        }
        
        // --- Unlink Modal Logic ---
        function openUnlinkModal(sourceId) {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk || !sourceChunk.links || sourceChunk.links.length === 0) {
                showMessage("No Relationships", "This idea has no outgoing relationships to manage.");
                return;
            }
            unlinkList.innerHTML = '';
            sourceChunk.links.forEach(link => {
                const targetChunk = chunksMap.get(link.targetId);
                if (targetChunk) {
                    const item = document.createElement('div');
                    item.className = 'flex justify-between items-center p-2 unlink-item rounded-md';
                    let labelText = link.label ? `"${link.label}"` : '(No Note)';
                    item.innerHTML = `<span>To: <strong>${targetChunk.chunkTypeTag}</strong> ${labelText}</span>`;
                    
                    const btnGroup = document.createElement('div');

                    const editBtn = document.createElement('button');
                    editBtn.className = 'btn btn-secondary btn-sm !m-0 mr-2';
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => {
                         hideModal(unlinkModal);
                         openLinkEditor(sourceId, link.targetId, link.label, link.type);
                    };

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger btn-sm !m-0';
                    removeBtn.textContent = 'Remove';
                    removeBtn.onclick = () => {
                        sourceChunk.links = sourceChunk.links.filter(l => l.targetId !== link.targetId);
                        item.remove();
                        drawConnections();
                        updateSelectedVisuals();
                        saveStateToLocalStorage();
                        if (sourceChunk.links.length === 0) {
                            hideModal(unlinkModal);
                        }
                    };
                    btnGroup.appendChild(editBtn);
                    btnGroup.appendChild(removeBtn);
                    item.appendChild(btnGroup);
                    unlinkList.appendChild(item);
                }
            });
            showModal(unlinkModal);
        }

        function openLinkEditor(sourceId, targetId, label = '', linkType = 'triggers') {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk) return;

            linkSourceIdInput.value = sourceId;
            linkTargetIdInput.value = targetId;
            linkLabelInput.value = label;
            
            populateSelectWithOptions(linkTypeSelect, LINK_TYPES.map(l => ({value: l.type, text: l.label})), linkType);

            const existingLink = sourceChunk.links.find(l => l.targetId === targetId);
            linkEditTitle.textContent = existingLink ? 'Edit Relationship' : 'Create Relationship';
            confirmLinkEditBtn.textContent = existingLink ? 'Save Changes' : 'Create Link';
            
            showModal(linkEditModal);
        }

        // --- Interaction Logic (Drag, Resize, Pan, Zoom) ---
        function onInteractionStart(e) {
            const isTouchEvent = e.type.startsWith('touch');

            if (linkingMode) {
                if (isTouchEvent) {
                     e.preventDefault();
                     e.stopPropagation(); 
                     const targetChunk = e.target.closest('.chorus-chunk');
                     if (targetChunk) {
                        const targetChunkId = targetChunk.id;
                         if (linkingSourceChunkId && linkingSourceChunkId !== targetChunkId) {
                            completeLink(linkingSourceChunkId, targetChunkId);
                        } else if (linkingSourceChunkId === targetChunkId) {
                            if (!e.target.closest('.chunk-action-btn')) {
                                cancelLinkingMode(false);
                            }
                        }
                     }
                }
                return;
            }
            
            if (isTouchEvent && e.touches.length > 1) return; 
            if (isTouchEvent) e.preventDefault(); 
            const pointer = getPointerCoordinates(e); 
            interactionStartX = pointer.x; 
            interactionStartY = pointer.y; 
            if (e.target.classList.contains('resize-handle')) { 
                currentAction = 'resize'; 
                resizingChunk = e.target.closest('.chorus-chunk'); 
                if (!resizingChunk) { currentAction = null; return; } 
                e.stopPropagation(); 
                selectChunk(resizingChunk.id); 
                highestZIndex++; resizingChunk.style.zIndex = String(highestZIndex); 
                const chunkData = chunksMap.get(resizingChunk.id); 
                if(chunkData) chunkData.zIndex = highestZIndex; 
                startX = pointer.x; startY = pointer.y; 
                startWidth = parseFloat(resizingChunk.style.width); 
                startHeight = parseFloat(resizingChunk.style.height); 
            } else if (e.target.closest('.chunk-header')) { 
                if (e.target.closest('.chunk-action-btn')) return; 
                currentAction = 'drag'; 
                draggedChunk = e.target.closest('.chorus-chunk'); 
                if (!draggedChunk) { currentAction = null; return; } 
                e.stopPropagation(); 
                selectChunk(draggedChunk.id); 
                highestZIndex++; 
                draggedChunk.style.zIndex = String(highestZIndex); 
                const chunkData = chunksMap.get(draggedChunk.id); 
                if(chunkData) chunkData.zIndex = highestZIndex; 
                const worldPointer = screenToWorld(pointer.x, pointer.y); 
                offsetX = worldPointer.x - parseFloat(draggedChunk.style.left); 
                offsetY = worldPointer.y - parseFloat(draggedChunk.style.top); 
            } 
            if (currentAction === 'drag' || currentAction === 'resize') { 
                document.addEventListener('mousemove', onInteractionMove); 
                document.addEventListener('mouseup', onInteractionEnd); 
                document.addEventListener('touchmove', onInteractionMove, { passive: false }); 
                document.addEventListener('touchend', onInteractionEnd); 
            } 
        }
        let interactionMoveQueued = false;
        function onInteractionMove(e) { const isTouchEvent = e.type.startsWith('touch'); if (!currentAction) return; if (isTouchEvent) e.preventDefault(); if (interactionMoveQueued) return; interactionMoveQueued = true; requestAnimationFrame(() => { const pointer = getPointerCoordinates(e); if (currentAction === 'drag' && draggedChunk) { const worldPointer = screenToWorld(pointer.x, pointer.y); let newWorldX = worldPointer.x - offsetX; let newWorldY = worldPointer.y - offsetY; const canvasWorldWidth = noteCanvas.scrollWidth; const canvasWorldHeight = noteCanvas.scrollHeight; const chunkWidth = parseFloat(draggedChunk.style.width); const chunkHeight = parseFloat(draggedChunk.style.height); newWorldX = Math.max(0, Math.min(newWorldX, canvasWorldWidth - chunkWidth)); newWorldY = Math.max(0, Math.min(newWorldY, canvasWorldHeight - chunkHeight)); draggedChunk.style.left = newWorldX + 'px'; draggedChunk.style.top = newWorldY + 'px'; drawConnections(); } else if (currentAction === 'resize' && resizingChunk) { const deltaScreenX = pointer.x - startX; const deltaScreenY = pointer.y - startY; let newWidth = startWidth + (deltaScreenX / scale); let newHeight = startHeight + (deltaScreenY / scale); newWidth = Math.max(250, newWidth); newHeight = Math.max(150, newHeight); const chunkCurrentX = parseFloat(resizingChunk.style.left); const chunkCurrentY = parseFloat(resizingChunk.style.top); const canvasWorldWidth = noteCanvas.scrollWidth; const canvasWorldHeight = noteCanvas.scrollHeight; if (chunkCurrentX + newWidth > canvasWorldWidth) newWidth = canvasWorldWidth - chunkCurrentX; if (chunkCurrentY + newHeight > canvasWorldHeight) newHeight = canvasWorldHeight - chunkCurrentY; resizingChunk.style.width = newWidth + 'px'; resizingChunk.style.height = newHeight + 'px'; drawConnections(); } else if (currentAction === 'pan') { translateX = pointer.x - panStartX; translateY = pointer.y - panStartY; applyTransform(); } interactionMoveQueued = false; }); }
        function onInteractionEnd(e) { 
            if (currentAction === 'drag' && draggedChunk) { const chunkData = chunksMap.get(draggedChunk.id); if (chunkData) { chunkData.x = parseFloat(draggedChunk.style.left); chunkData.y = parseFloat(draggedChunk.style.top); } draggedChunk = null; saveStateToLocalStorage(); } 
            else if (currentAction === 'resize' && resizingChunk) { const chunkData = chunksMap.get(resizingChunk.id); if (chunkData) { chunkData.width = parseFloat(resizingChunk.style.width); chunkData.height = parseFloat(resizingChunk.style.height); } resizingChunk = null; saveStateToLocalStorage(); } 
            else if (currentAction === 'pan') { noteCanvasContainer.classList.remove('panning'); saveStateToLocalStorage(); } 
            if (currentAction !== 'pinch-zoom') { currentAction = null; } 
            document.removeEventListener('mousemove', onInteractionMove); document.removeEventListener('mouseup', onInteractionEnd); document.removeEventListener('touchmove', onInteractionMove); document.removeEventListener('touchend', onInteractionEnd); 
        }
        
        // --- Save/Load & Export ---
        function saveCanvasAsTemplate() {
            if (chunks.length === 0) {
                showMessage("Empty Canvas", "There is nothing on the canvas to save as a template.");
                return;
            }
            
            let templateChunks = JSON.parse(JSON.stringify(chunks));
            templateChunks.forEach(chunkData => {
                const chunkElement = document.getElementById(chunkData.id);
                if (chunkElement) {
                    const contentDiv = chunkElement.querySelector('.chunk-content');
                    if (contentDiv) chunkData.text = contentDiv.innerHTML;
                }
            });

            let minX = Infinity;
            let minY = Infinity;
            templateChunks.forEach(chunk => {
                minX = Math.min(minX, chunk.x);
                minY = Math.min(minY, chunk.y);
            });
            
            templateChunks.forEach(chunk => {
                chunk.x -= minX;
                chunk.y -= minY;
            });

            const templateData = {
                name: "Custom Template",
                description: "A template saved from the canvas.",
                chunks: templateChunks,
                links: [] 
            };

            const idMap = new Map();
            templateChunks.forEach((chunk, index) => {
                const oldId = chunk.id;
                const newId = `template_chunk_${index}`;
                idMap.set(oldId, newId);
                chunk.id = newId;
            });

            templateChunks.forEach(chunk => {
                if(chunk.links) {
                    chunk.links.forEach(link => {
                        link.targetId = idMap.get(link.targetId);
                    });
                    chunk.links = chunk.links.filter(link => link.targetId);
                }
            });
            
            templateData.links = [];
            templateChunks.forEach(chunk => {
                if(chunk.links) {
                    chunk.links.forEach(link => {
                        templateData.links.push({
                            from: chunk.id,
                            to: link.targetId,
                            label: link.label,
                            type: link.type
                        });
                    });
                }
            });


            const dataStr = JSON.stringify(templateData, null, 2);
            downloadFile(dataStr, 'chorus-template.chtml', 'application/json');
            showMessage('Template Saved', 'Your custom template has been prepared for download.');
        }

        function saveDataToFile() { chunks.forEach(chunkData => { const chunkElement = document.getElementById(chunkData.id); if (chunkElement) { const contentDiv = chunkElement.querySelector('.chunk-content'); if (contentDiv) { chunkData.text = contentDiv.innerHTML; } } }); if (chunks.length === 0) { showMessage("Empty Board", "There are no notes to save."); return; } try { const dataToSave = { chunks: chunks, viewport: { scale: scale, translateX: translateX, translateY: translateY } }; const dataStr = JSON.stringify(dataToSave, null, 2); downloadFile(dataStr, 'core-perceptual-map.json', 'application/json'); showMessage('Saved to File', 'Your board has been prepared for download.'); } catch (error) { showMessage('Save Error', `Could not prepare data for saving: ${error.message}`); console.error("Save error:", error); } }
        function downloadFile(content, fileName, contentType) { const a = document.createElement('a'); const file = new Blob([content], {type: contentType}); a.href = URL.createObjectURL(file); a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); }
        
        function exportTo(format) {
            let content = '';
            let fileExt = '';
            let mimeType = 'text/plain';
            let fileName = ''; // Variable to hold the final filename

            const tempDiv = document.createElement('div');
            function cleanText(html) {
                tempDiv.innerHTML = html.replace(/<br\s*[\/]?>/gi, "\n").replace(/<p>/gi, "").replace(/<\/p>/gi, "\n\n");
                return (tempDiv.textContent || tempDiv.innerText || "").trim();
            }

            function escapeForRenpy(text) {
                return text.replace(/"/g, '\\"').replace(/\n/g, '\\n');
            }
            
            chunks.forEach(chunkData => {
                 const chunkElement = document.getElementById(chunkData.id);
                 if (chunkElement) {
                     const contentDiv = chunkElement.querySelector('.chunk-content');
                     if(contentDiv) chunkData.text = contentDiv.innerHTML;
                 }
            });

            const exportActions = {
                'json': () => {
                    content = JSON.stringify({ chunks: chunks }, null, 2);
                    fileExt = 'json';
                    mimeType = 'application/json';
                },
                'narrative-txt': () => {
                    fileExt = 'txt';
                    mimeType = 'text/plain;charset=utf-8';
                    const formatTypeTagForNarrative = (tag) => {
                        const descriptiveText = tag.replace('#', '').replace(/-/g, ' ');
                        const article = /^[aeiou]/i.test(descriptiveText) ? 'An' : 'A';
                        return `${article} ${descriptiveText}.`;
                    };
                    chunks.forEach((chunk, index) => {
                        const shapeInfo = SHAPES.find(s => s.name === chunk.shape) || { essence: 'not specified' };
                        const colorInfo = COLORS.find(c => c.name === chunk.color) || { essence: 'not specified' };
                        content += `--- SECTION ${index + 1} (${chunk.chunkTypeTag}) ---\n\n`;
                        content += `${formatTypeTagForNarrative(chunk.chunkTypeTag)}\n\n`;
                        content += `${cleanText(chunk.text)}\n\n`;
                        content += `(This moment is perceived as a functional '${shapeInfo.essence.toLowerCase()}' with an emotional tone of '${colorInfo.essence.toLowerCase()}'.)\n\n`;
                        if (chunk.links && chunk.links.length > 0) {
                            content += 'From here, the story continues:\n';
                            chunk.links.forEach(link => {
                                const target = chunksMap.get(link.targetId);
                                const linkTypeInfo = LINK_TYPES.find(lt => lt.type === link.type) || { label: link.type };
                                let linkDescription = link.label || linkTypeInfo.label;
                                if (target) {
                                    const targetIndex = chunks.findIndex(c => c.id === target.id);
                                    if (targetIndex !== -1) { content += `  - ${linkDescription}. (Continue to SECTION ${targetIndex + 1})\n`; } 
                                    else { content += `  - ${linkDescription}, but the destination is missing.\n`; }
                                } else { content += `  - ${linkDescription}, leading to an unknown destination.\n`; }
                            });
                            content += `\n`;
                        } else { content += 'This is the end of this path.\n\n'; }
                        content += `------------------------------------------\n\n`;
                    });
                },
                'yarn': () => {
                    fileExt = 'yarn';
                    chunks.forEach(chunk => {
                        content += `title: ${chunk.id}\n`;
                        content += `tags: ${chunk.chunkTypeTag.replace('#','')} ${chunk.shape} ${chunk.color}\n`;
                        content += `---\n`;
                        content += `${cleanText(chunk.text)}\n`;
                        if (chunk.links) {
                            chunk.links.forEach(link => {
                                let linkText = link.label || `Continue (${link.type})`;
                                content += `[[${linkText}|${link.targetId}]]\n`;
                            });
                        }
                        content += `===\n`;
                    });
                },
                'twee': () => {
                     fileExt = 'twee';
                     chunks.forEach(chunk => {
                        content += `:: ${chunk.id} [${chunk.chunkTypeTag.replace('#','')} ${chunk.shape} ${chunk.color}]\n`;
                        content += `${cleanText(chunk.text)}\n`;
                        if (chunk.links) {
                            chunk.links.forEach(link => {
                                let linkText = link.label || `Continue (${link.type})`;
                                content += `[[${linkText}->${link.targetId}]]\n`;
                            });
                        }
                        content += `\n`;
                    });
                },
                'ink': () => {
                    fileExt = 'ink';
                    chunks.forEach(chunk => {
                        content += `=== ${chunk.id} ===\n`;
                        content += `${cleanText(chunk.text)}\n`;
                        if (chunk.links && chunk.links.length > 0) {
                            chunk.links.forEach(link => {
                                let linkText = link.label || `Continue (${link.type})`;
                                content += `* ${linkText} -> ${link.targetId}\n`;
                            });
                        } else { content += '-> END\n'; }
                        content += `\n`;
                    });
                },
                'renpy': () => {
                    fileExt = 'rpy';
                    // Helper to remove file extensions for renpy commands like 'scene' and 'show'
                    const stripExt = (filename) => filename.split('.').slice(0, -1).join('.') || filename;

                    content += 'label start:\n';
                    // Find a likely starting chunk (one that isn't a target of another chunk)
                    const firstChunk = chunks.find(c => !chunks.some(other => other.links && other.links.some(l => l.targetId === c.id))) || chunks[0];
                    if (firstChunk) { 
                        content += `    jump ${firstChunk.id}\n\n`; 
                    } else {
                        content += '    "Please create some ideas to begin the story."\n    return\n\n';
                    }

                    chunks.forEach(chunk => {
                        content += `label ${chunk.id}:\n`;

                        // --- NEW: Add asset commands ---
                        if (chunk.renpy_bg) {
                            content += `    scene ${stripExt(chunk.renpy_bg)}\n`;
                        }
                        if (chunk.renpy_music) {
                            content += `    play music "audio/${chunk.renpy_music}"\n`;
                        }
                        if (chunk.renpy_sprite) {
                            content += `    show ${stripExt(chunk.renpy_sprite)}\n`;
                        }
                        // --- END NEW ---

                        // Add a pause for effect, makes the flow better in-game
                        if (chunk.renpy_bg || chunk.renpy_sprite) {
                            content += `    with dissolve\n\n`;
                        }

                        content += `    "${escapeForRenpy(cleanText(chunk.text))}"\n\n`;

                        if (chunk.links && chunk.links.length > 0) {
                            if (chunk.links.length === 1) {
                                // If only one link, just jump to it directly.
                                content += `    jump ${chunk.links[0].targetId}\n`;
                            } else {
                                // If multiple links, create a choice menu.
                                content += '    menu:\n';
                                chunk.links.forEach(link => {
                                    let linkText = escapeForRenpy(link.label || `Continue (${link.type})`);
                                    content += `        "${linkText}":\n`;
                                    content += `            jump ${link.targetId}\n`;
                                });
                            }
                        } else {
                            content += '    "The end."\n';
                            content += '    return\n';
                        }
                        content += '\n';
                    });
                },
                'i7': () => {
                    fileExt = 'ni';
                    content = `Volume - CORE Export\n\nBook - Story\n\n`;
                    chunks.forEach(chunk => {
                        let roomName = `${chunk.chunkTypeTag.replace('#','')} (${chunk.id.substring(0,5)})`.replace(/-/g, ' ');
                        content += `"${roomName}" is a room. "${cleanText(chunk.text)}".\n\n`;
                    });
                    chunks.forEach(chunk => {
                         if (chunk.links && chunk.links.length > 0) {
                             let sourceRoomName = `${chunk.chunkTypeTag.replace('#','')} (${chunk.id.substring(0,5)})`.replace(/-/g, ' ');
                             chunk.links.forEach(link => {
                                 const targetChunk = chunksMap.get(link.targetId);
                                 if (targetChunk) {
                                    let targetRoomName = `${targetChunk.chunkTypeTag.replace('#','')} (${targetChunk.id.substring(0,5)})`.replace(/-/g, ' ');
                                    let direction = `The path labeled "${link.label || link.type}"`;
                                    content += `${direction} leads to "${targetRoomName}" from "${sourceRoomName}".\n`;
                                 }
                             });
                             content += '\n';
                         }
                    });
                },
                'txt': () => {
                    fileExt = 'txt';
                    chunks.forEach(chunk => {
                        content += `--- IDEA: ${chunk.id} ---\n`;
                        content += `Type: ${chunk.chunkTypeTag} | Shape: ${chunk.shape} | Color: ${chunk.color}\n\n`;
                        content += `${cleanText(chunk.text)}\n\n`;
                        if (chunk.links && chunk.links.length > 0) {
                            content += 'Relationships:\n';
                            chunk.links.forEach(link => {
                                const target = chunksMap.get(link.targetId);
                                const linkInfo = LINK_TYPES.find(lt => lt.type === link.type) || {label: link.type};
                                content += `  -> ${linkInfo.label} to: ${target ? target.chunkTypeTag : 'Unknown'} (${link.targetId})\n`;
                                if(link.label) content += `     Note: "${link.label}"\n`;
                            });
                        }
                        content += `\n\n`;
                    });
                }
            };

            if (exportActions[format]) {
                exportActions[format]();

                // Set a default filename first
                fileName = `coreps-export.${fileExt}`;
                // Now, create a special case for the narrative text format
                if (format === 'narrative-txt') {
                    fileName = `chorus-narrative.${fileExt}`;
                }
                
                downloadFile(content, fileName, mimeType);
            }
        }

        function renderBoard(loadedChunksData) {
            const existingChunkElements = noteCanvas.querySelectorAll('.chorus-chunk'); existingChunkElements.forEach(el => el.remove());
            chunks = loadedChunksData || []; chunksMap.clear(); highestZIndex = 0; selectedChunkId = null; lastDeletedChunk = null; undoDeleteBtn.disabled = true; cancelLinkingMode(true);
            if (Array.isArray(chunks)) { chunks.forEach(chunkData => { chunkData.links = chunkData.links || []; if (chunkData && chunkData.id && chunkData.chunkTypeTag) { chunksMap.set(chunkData.id, chunkData); createChunkElement(chunkData); if (chunkData.zIndex > highestZIndex) { highestZIndex = chunkData.zIndex; } } else { console.warn("Skipping invalid chunk data during render:", chunkData); } }); }
            if(chunks.length === 0) highestZIndex = 1;
            updateSelectedVisuals(); drawConnections(); updateChunkCounter(); populateChunkList();
        }

        function openEditChunkModal(chunkId) {
            const chunkData = chunksMap.get(chunkId);
            if (!chunkData) return;
            editingChunkIdInput.value = chunkId;
            populateSelectWithOptions(editChunkTypeSelect, null, chunkData.chunkTypeTag, chunkTypes, key => key.charAt(0).toUpperCase() + key.slice(1) + " Types");
            populateSelectWithOptions(editChunkShapeSelect, SHAPES.map(s => ({value: s.name, text: `${s.symbol} ${s.name} - ${s.essence}`})), chunkData.shape);
            populateSelectWithOptions(editChunkColorSelect, COLORS.map(c => ({value: c.name, text: `${c.symbol} ${c.name} - ${c.essence}`})), chunkData.color);

            const actionsDiv = document.getElementById('editModalActions');
            let manageBtn = document.getElementById('manageLinksBtn');
            if (!manageBtn) {
                manageBtn = document.createElement('button');
                manageBtn.id = 'manageLinksBtn';
                manageBtn.className = 'btn btn-secondary';
                manageBtn.textContent = 'Manage Relationships';
                actionsDiv.insertBefore(manageBtn, cancelEditChunkBtn);
            }
            manageBtn.onclick = () => {
                hideModal(editChunkModal);
                openUnlinkModal(chunkData.id);
            };

			// START: ADDED CODE - Populate Ren'Py fields
			document.getElementById('renpyBgInput').value = chunkData.renpy_bg || '';
			document.getElementById('renpySpriteInput').value = chunkData.renpy_sprite || '';
			document.getElementById('renpyMusicInput').value = chunkData.renpy_music || '';
			// END: ADDED CODE

            showModal(editChunkModal);
        }

        // --- Initialization Sequence ---
        function initializeApp() {
            function setViewportHeight() {
                // This calculates the real viewport height and sets it as a CSS variable (--vh)
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            }

            // Run the function on resize and orientation change
            window.addEventListener('resize', setViewportHeight);
            window.addEventListener('orientationchange', setViewportHeight);
            setViewportHeight(); // Run it once on initial load
            document.querySelectorAll('.copyrightYear').forEach(span => {
                span.textContent = new Date().getFullYear();
            });
            
            createCanvasHelpers();
            loadSettings();
            loadCustomChunkTypes(); 
            setupTemplateModal(); 
            populateAddChunkModal();
            renderBoard([]);
            
            // Event Listeners
            addChunkBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); showModal(addChunkModal); });
            templatesBtn.addEventListener('click', () => showModal(templatesModal));
            clearCanvasBtn.addEventListener('click', () => { if (linkingMode) cancelLinkingMode(false); if (chunks.length === 0) { showMessage("Canvas Empty", "The canvas is already clear."); return; } showMessage("Confirm Clear", "Are you sure you want to clear the entire canvas? This action cannot be undone and will also remove your auto-saved session.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Clear Canvas', class: 'btn-danger', action: () => { renderBoard([]); clearAutoSave(); showMessage("Canvas Cleared", "All ideas and links have been removed."); }} ]); });
            undoDeleteBtn.addEventListener('click', () => { if (linkingMode) cancelLinkingMode(false); undoDeleteLastChunk(); });
            saveBtn.addEventListener('click', saveDataToFile);
            loadBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); if (chunks.length > 0) { showMessage("Confirm Load", "Loading a new file will clear any unsaved changes on the current canvas. Are you sure you want to proceed?", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load File', class: 'btn-primary', action: () => fileLoadInput.click() } ]); } else { fileLoadInput.click(); } });
            settingsBtn.addEventListener('click', () => showModal(settingsModal));
            helpBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); showModal(helpModal); });
            
            // New Donate Modal Listeners
            const openDonateModal = () => showModal(donateModal);
            donateBtn.addEventListener('click', openDonateModal);
            helpDonateBtn.addEventListener('click', () => {
                hideModal(helpModal);
                openDonateModal();
            });
            closeDonateModalBtn.addEventListener('click', () => hideModal(donateModal));
            closeDonateModalOkBtn.addEventListener('click', () => hideModal(donateModal));


            exportBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                exportDropdownContent.classList.toggle('show');
            });
            document.querySelectorAll('#exportDropdownContent button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const format = e.target.dataset.format;
                    if(format === 'articy') {
                        showMessage("articy:draft Export", "Direct export to articy:draft is not supported due to its complex project format. To get your data into articy, you would typically use its API or import an XML/JSON file with a specific structure.<br><br>As an alternative, please use the <strong>JSON export</strong> option. You can then use that JSON data with a custom script to import it into your articy:draft project.");
                    } else {
                        exportTo(format);
                    }
                    exportDropdownContent.classList.remove('show');
                });
            });
            
            saveCanvasAsTemplateBtn.addEventListener('click', saveCanvasAsTemplate);
            loadCustomTemplateBtn.addEventListener('click', () => templateLoadInput.click());

            cancelAddChunkBtn.addEventListener('click', () => hideModal(addChunkModal));
            confirmAddChunkBtn.addEventListener('click', () => { 
                const selectedType = allChunkTypesList.find(ct => ct.tag === chunkTypeSelect.value); 
                const selectedShapeName = addChunkShapeSelect.value;
                const selectedColorName = addChunkColorSelect.value;
                if (!selectedType) { showMessage('Error', 'Please make a selection for idea type.'); return; } 
                const newChunkData = addChunkToCanvas({ type: selectedType, shape: selectedShapeName, color: selectedColorName }); 
                centerOnChunk(newChunkData.id, true);
                hideModal(addChunkModal); 
            });
            cancelEditChunkBtn.addEventListener('click', () => hideModal(editChunkModal));
            confirmEditChunkBtn.addEventListener('click', () => { const chunkId = editingChunkIdInput.value; const chunkData = chunksMap.get(chunkId); if (!chunkData) return; const newType = allChunkTypesList.find(ct => ct.tag === editChunkTypeSelect.value); const newShapeName = editChunkShapeSelect.value; const newColorName = editChunkColorSelect.value; if (!newType || !newShapeName || !newColorName) { showMessage('Error', 'Invalid selection.'); return; } chunkData.chunkTypeTag = newType.tag; chunkData.shape = newShapeName; 
			chunkData.color = newColorName;
			// START: ADDED CODE - Save Ren'Py asset info
			chunkData.renpy_bg = document.getElementById('renpyBgInput').value.trim();
			chunkData.renpy_sprite = document.getElementById('renpySpriteInput').value.trim();
			chunkData.renpy_music = document.getElementById('renpyMusicInput').value.trim();
			// END: ADDED CODE
			updateChunkHeaderDisplay(chunkId); 
            hideModal(editChunkModal); 
            updateSelectedVisuals(); 
            drawConnections(); 
            populateChunkList(); 
            saveStateToLocalStorage(); 
        });
            closeHelpBtn.addEventListener('click', () => hideModal(helpModal));
            closeHelpModalSpan.addEventListener('click', () => hideModal(helpModal));
            closeUnlinkModalBtn.addEventListener('click', () => hideModal(unlinkModal));
            cancelLinkEditBtn.addEventListener('click', () => { hideModal(linkEditModal); cancelLinkingMode(false); });
            confirmLinkEditBtn.addEventListener('click', () => {
                const sourceId = linkSourceIdInput.value;
                const targetId = linkTargetIdInput.value;
                const label = linkLabelInput.value;
                const type = linkTypeSelect.value;
                addOrUpdateLink(sourceId, targetId, label, type);
                hideModal(linkEditModal);
                cancelLinkingMode(false);
            });
            fileLoadInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (!file) return; if (file.type !== "application/json") { showMessage("Load Error", "Invalid file type. Please select a .json file."); event.target.value = null; return; } const reader = new FileReader(); reader.onload = (e) => { try { const loadedData = JSON.parse(e.target.result); if (loadedData && Array.isArray(loadedData.chunks)) { renderBoard(loadedData.chunks); if (loadedData.viewport) { scale = loadedData.viewport.scale || 1; translateX = loadedData.viewport.translateX || 0; translateY = loadedData.viewport.translateY || 0; applyTransform(); } else { resetAndCenterView(); } showMessage('Loaded from File', `Successfully loaded notes from ${file.name}.`); saveStateToLocalStorage(); } else { throw new Error("Invalid file format. Expected 'chunks' array."); } } catch (error) { showMessage('Load Error', `Could not load or parse file: ${error.message}.`); console.error("Load error:", error); } finally { event.target.value = null; } }; reader.onerror = () => { showMessage('Load Error', `Error reading file: ${reader.error}`); event.target.value = null; console.error("File read error:", reader.error); }; reader.readAsText(file); });
            templateLoadInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const templateData = JSON.parse(e.target.result); if (templateData && Array.isArray(templateData.chunks)) { showMessage("Confirm Load Template", `This will clear the current canvas. Are you sure you want to load the template "${file.name}"?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load Template', class: 'btn-primary', action: () => { loadTemplate(templateData); hideModal(templatesModal); } } ]); } else { throw new Error("Invalid template file format."); } } catch (error) { showMessage('Load Error', `Could not load or parse template file: ${error.message}.`); console.error("Load error:", error); } finally { event.target.value = null; } }; reader.onerror = () => { showMessage('Load Error', `Error reading template file: ${reader.error}`); event.target.value = null; }; reader.readAsText(file); });
            
            closeSettingsModalBtn.addEventListener('click', () => hideModal(settingsModal));
            saveSettingsBtn.addEventListener('click', () => { saveSettings(); hideModal(settingsModal); });
            
            gridToggle.addEventListener('change', () => { appSettings.showGrid = gridToggle.checked; applySettings(); });
            centerStarToggle.addEventListener('change', () => { appSettings.showCenterStar = centerStarToggle.checked; applySettings(); });
            bgAnimationToggle.addEventListener('change', () => { appSettings.bgAnimationOn = bgAnimationToggle.checked; applySettings(); });
            bgAnimationSpeed.addEventListener('input', () => { appSettings.bgAnimationSpeed = bgAnimationSpeed.value; applySettings(); });
            themeSelect.addEventListener('input', () => { appSettings.theme = themeSelect.value; applySettings(); });

            aiActionDeepenBtn.addEventListener('click', handleDeepenSensoryDetails);
            aiActionInternalStateBtn.addEventListener('click', handleExploreInternalState);
			aiActionSuggestEchoBtn.addEventListener('click', handleSuggestEcho);

            const getViewportCenterForZoom = () => { const rect = noteCanvasContainer.getBoundingClientRect(); return { x: rect.width / 2, y: rect.height / 2 }; };
            zoomInBtn.addEventListener('click', () => { const center = getViewportCenterForZoom(); zoomAtPoint(scale * 1.25, center.x, center.y); });
            zoomOutBtn.addEventListener('click', () => { const center = getViewportCenterForZoom(); zoomAtPoint(scale / 1.25, center.y); });
            zoomResetBtn.addEventListener('click', resetAndCenterView);
            chunkListToggleBtn.addEventListener('click', toggleChunkList);

            noteCanvasContainer.addEventListener('mousedown', (e) => { if (e.target === noteCanvasContainer || e.target === transformContainer || e.target === noteCanvas) { if (linkingMode) { deselectAllChunks(); return; } currentAction = 'pan'; const pointer = getPointerCoordinates(e); panStartX = pointer.x - translateX; panStartY = pointer.y - translateY; noteCanvasContainer.classList.add('panning'); document.addEventListener('mousemove', onInteractionMove); document.addEventListener('mouseup', onInteractionEnd); } else if (!e.target.closest('.chorus-chunk') && !e.target.closest('.toolbar') && !e.target.closest('.modal')) { deselectAllChunks(); } });
            noteCanvasContainer.addEventListener('touchstart', (e) => { if (e.target === noteCanvasContainer || e.target === transformContainer || e.target === noteCanvas) { if (e.touches.length === 1) { if (linkingMode) { deselectAllChunks(); e.preventDefault(); return; } e.preventDefault(); currentAction = 'pan'; const pointer = getPointerCoordinates(e); panStartX = pointer.x - translateX; panStartY = pointer.y - translateY; noteCanvasContainer.classList.add('panning'); document.addEventListener('touchmove', onInteractionMove, { passive: false }); document.addEventListener('touchend', onInteractionEnd); } else if (e.touches.length === 2) { e.preventDefault(); currentAction = 'pinch-zoom'; noteCanvasContainer.classList.remove('panning'); const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }; const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }; initialPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y); } }  else if (!e.target.closest('.chorus-chunk') && !e.target.closest('.toolbar') && !e.target.closest('.modal')) { deselectAllChunks(); e.preventDefault(); } }, { passive: false });
            noteCanvasContainer.addEventListener('wheel', (e) => { e.preventDefault(); const rect = noteCanvasContainer.getBoundingClientRect(); const mouseX = e.clientX - (rect.left || 0); const mouseY = e.clientY - (rect.top || 0); const delta = e.deltaY * ZOOM_SENSITIVITY * -1; const newScale = scale * (1 + delta); zoomAtPoint(newScale, mouseX, mouseY); saveStateToLocalStorage(); }, { passive: false });
            noteCanvasContainer.addEventListener('touchmove', (e) => { if (currentAction === 'pinch-zoom' && e.touches.length === 2) { e.preventDefault(); const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }; const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }; const currentPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y); const pinchMidpointScreen = { x: (t1.x + t2.x) / 2, y: (t1.y + t2.y) / 2 }; if (initialPinchDistance === null) { initialPinchDistance = currentPinchDistance; return; } const rect = noteCanvasContainer.getBoundingClientRect(); const worldMidXBeforeZoom = (pinchMidpointScreen.x - (rect.left || 0) - translateX) / scale; const worldMidYBeforeZoom = (pinchMidpointScreen.y - (rect.top || 0) - translateY) / scale; let scaleChange = currentPinchDistance / initialPinchDistance; let newScale = scale * scaleChange; newScale = Math.max(MIN_SCALE, Math.min(newScale, MAX_SCALE)); translateX = (pinchMidpointScreen.x - (rect.left || 0)) - worldMidXBeforeZoom * newScale; translateY = (pinchMidpointScreen.y - (rect.top || 0)) - worldMidYBeforeZoom * newScale; scale = newScale; applyTransform(); initialPinchDistance = currentPinchDistance; } }, { passive: false });
            noteCanvasContainer.addEventListener('touchend', (e) => { if (e.touches.length < 2 && currentAction === 'pinch-zoom') { initialPinchDistance = null; currentAction = null; saveStateToLocalStorage(); } });
            document.addEventListener('keydown', (e) => { const activeEl = document.activeElement; const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable); const isCtrlOrCmd = e.ctrlKey || e.metaKey; let shortcutHandled = false; if (isCtrlOrCmd) { switch (e.key.toLowerCase()) { case 's': saveBtn.click(); shortcutHandled = true; break; case 'o': loadBtn.click(); shortcutHandled = true; break; case 'z': if (!undoDeleteBtn.disabled) { undoDeleteBtn.click(); shortcutHandled = true; } break; } } if(shortcutHandled){ e.preventDefault(); return; } if (isInputFocused) { if (e.key === 'Escape') { activeEl.blur(); } return; } switch(e.key.toLowerCase()){ case 'escape': if (!addChunkModal.classList.contains('hidden')) { hideModal(addChunkModal); } else if (!editChunkModal.classList.contains('hidden')) { hideModal(editChunkModal); } else if (!helpModal.classList.contains('hidden')) { hideModal(helpModal); } else if (!messageModal.classList.contains('hidden')) { hideModal(messageModal); } else if (!settingsModal.classList.contains('hidden')) { hideModal(settingsModal); } else if (!aiActionModal.classList.contains('hidden')) { hideModal(aiActionModal); } else if (!chunkListPanel.classList.contains('hidden')) { toggleChunkList(); } else if (linkingMode) { cancelLinkingMode(false); } else if (selectedChunkId) { deselectAllChunks(); } shortcutHandled = true; break; case 'delete': case 'backspace': if (selectedChunkId) { showMessage("Confirm Delete", `Are you sure you want to delete the selected idea (${chunksMap.get(selectedChunkId)?.chunkTypeTag || 'idea'})?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Delete', class: 'btn-danger', action: () => { deleteChunk(selectedChunkId); }} ]); shortcutHandled = true; } break; case 'a': addChunkBtn.click(); shortcutHandled = true; break; case '?': case '/': helpBtn.click(); shortcutHandled = true; break; case '+': case '=': zoomInBtn.click(); shortcutHandled = true; break; case '-': case '_': zoomOutBtn.click(); shortcutHandled = true; break; case 'l': chunkListToggleBtn.click(); shortcutHandled = true; break; } if(shortcutHandled){ e.preventDefault(); } });
            
            window.addEventListener('click', (event) => { 
                if (exportDropdownContent.classList.contains('show') && !exportBtn.contains(event.target)) { 
                    exportDropdownContent.classList.remove('show'); 
                }
                if (!chunkListPanel.classList.contains('hidden') && !chunkListToggleBtn.contains(event.target) && !chunkListPanel.contains(event.target)) {
                    toggleChunkList();
                }
            });

            // START: New Event Listeners for Session Restore
            restoreContinueBtn.addEventListener('click', () => hideModal(sessionRestoreModal));
            restoreStartFreshBtn.addEventListener('click', () => {
                hideModal(sessionRestoreModal);
                renderBoard([]); // Clear board
                clearAutoSave(); // Clear storage
                showMessage("Canvas Cleared", "Started a fresh session.");
            });
            // END: New Event Listeners

            let resizeQueued = false;
            window.addEventListener('resize', () => { if (resizeQueued) return; resizeQueued = true; requestAnimationFrame(() => { const mainContent = document.getElementById('mainContent'); const toolbarElement = document.querySelector('.toolbar'); const footerElement = document.querySelector('footer'); let toolbarHeight = toolbarElement ? toolbarElement.offsetHeight : 0; let footerHeight = footerElement ? footerElement.offsetHeight : 0; if (mainContent) { mainContent.style.height = `calc(100vh - ${toolbarHeight}px - ${footerHeight}px)`; } applyTransform(); resizeQueued = false; }); });
            window.dispatchEvent(new Event('resize'));
            
            // Check for auto-saved data on initial load
            const savedDataRaw = localStorage.getItem(AUTOSAVE_KEY);
            if (savedDataRaw) {
                try {
                    const savedData = JSON.parse(savedDataRaw);
                    if (savedData && Array.isArray(savedData.chunks) && savedData.chunks.length > 0) {
                        renderBoard(savedData.chunks);
                        if (savedData.viewport) {
                            scale = savedData.viewport.scale || 1;
                            translateX = savedData.viewport.translateX || 0;
                            translateY = savedData.viewport.translateY || 0;
                            applyTransform();
                        } else {
                            resetAndCenterView();
                        }
                        showModal(sessionRestoreModal); // Show the restore modal
                    } else {
                        resetAndCenterView();
                    }
                } catch (e) {
                    console.error("Failed to parse auto-saved data:", e);
                    resetAndCenterView();
                }
            } else {
                 resetAndCenterView();
            }

            window.addEventListener('beforeunload', (event) => { if (chunks.length > 0) { event.preventDefault(); event.returnValue = ''; return ''; } });
            
            setTimeout(() => { document.getElementById('noteCanvasContainer').focus(); }, 100);
            
            console.log("CORE: Perceptual Storyteller Initialized");
        }
        initializeApp();
    });
    </script>
</body>
</html>
